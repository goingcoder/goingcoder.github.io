<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[极大似然估计法MLE]]></title>
      <url>/2018/03/10/mle/</url>
      <content type="html"><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 极大似然估计法（$Method  of  Maximum  Likelihood  Estimation –MLE$）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 极大似然估计法最早由高斯（C.F.Gauss）提出。后来为费歇在1912年的文章中重新提出，并且证明了这个方法的一些性质。极大似然估计这一名称也是费歇（R.A.Fisher）给的。这是一种目前仍然得到广泛应用的方法。它是建立在极大似然原理的基础上的一个统计方法。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 在数理统计学中，似然函数是一种关于统计模型中的<strong>参数</strong>的<strong>函数</strong>，表示模型参数中的似然性。 似然函数在统计推断中有重大作用，如在最大似然估计和费雪信息之中的应用等等。<strong>“似然性”与“或然性”或“概率”意思相近，都是指某种事件发生的可能性</strong>，但是在<strong>统计学</strong>中，“似然性”和“或然性”或“概率”又有明确的区分。<strong>概率</strong>用于在已知一些参数的情况下，预测接下来的观测所得到的结果，而<strong>似然性则是用于在已知某些观测所得到的结果时，对有关事物的性质的参数进行估计。</strong> 有人说，概率是已知模型和参数，推数据。统计是已知数据，推模型和参数。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 极大似然估计法的依据就是：<strong>概率最大的事件最可能发生</strong></p>
<a id="more"></a>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 极大似然估计法最早由高斯（C.F.Gauss）提出。后来为费歇在1912年的文章中重新提出，并且证明了这个方法的一些性质。极大似然估计这一名称也是费歇（R.A.Fisher）给的。这是一种目前仍然得到广泛应用的方法。它是建立在极大似然原理的基础上的一个统计方法。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 看论文的时候读到这样一句话：</p>
<p>​    <em>Assuming  the  training  instances  are  independently  sampled,the  likelihood  function  of  parameters   $\theta={w,\alpha,\beta}$ given  the  observations  D  can  be  factored  as</em><br>$$<br>Pr[D|\theta]=\prod_{i=1}^NPr[y_i^1,\dots,y_i^R|x_i;\theta]<br>$$<br>&nbsp; &nbsp; &nbsp; &nbsp; 原来只关注公式，所以一带而过。再重新看这个公式前的描述，细思极恐。</p>
<p> <em>the <strong>likelihood function</strong> of the parameters θ = {w,α,β} <strong>given the observations D</strong> can be factored as..</em></p>
<p><strong>两个疑问</strong>：</p>
<ul>
<li>likelihood function_为什么会写成条件概率的形式？</li>
<li><strong>given</strong>的明明是D，为什么到后面的公式里，却变成了$given  \theta$呢？</li>
</ul>
<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>常说的概率是指给定参数后，预测即将发生的事件的可能性</strong>。拿硬币这个例子来说，我们已知一枚均匀硬币的正反面概率分别是0.5，要预测抛两次硬币，硬币都朝上的概率：</p>
<p>$H$代表$Head$，表示头朝上</p>
<p>$p(HH | p_H = 0.5) = 0.5*0.5 = 0.25.$</p>
<p> &nbsp;   这种写法其实有点误导，后面的这个其实是作为参数存在的，而不是一个随机变量，因此不能算作是条件概率，更靠谱的写法应该是 $p(HH;p=0.5)。$</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;而似然概率正好与这个过程相反，<strong>我们关注的量</strong>不再是事件的发生概率，而是已<strong>知发生了某些事件，我们希望知道参数应该是多少。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们已经抛了两次硬币，并且知道了结果是两次头朝上，这时候，我希望知道这枚硬币抛出去正面朝上的概率为0.5的概率是多少？正面朝上的概率为0.8的概率是多少？</p>
<p>如果我们希望知道正面朝上概率为0.5的概率，这个东西就叫做似<strong>然函数</strong>，可以说成是对某一个参数的猜想$（p=0.5）$的概率，这样表示成(条件)概率就是</p>
<p>$L(p_H=0.5|HH) =P(HH|p_H=0.5) = $（另一种写法）$P(HH;p_H=0.5).$</p>
<p>为什么可以写成这样？我觉得可以这样来想：</p>
<p>$L(\theta|x)=f(x|\theta)$</p>
<p>这里$\theta$是未知参数，它属于参数空间。</p>
<p>&nbsp;$f(x|\theta)$是一个密度函数，特别地，它表示给定$\theta$ 下关于联合概率样本值$x$ 的联合密度函数。前者是关于$\theta$的函数，后者是关于$x$的函数。所以这里的等号理解为函数值形式的相等，而不是两个函数本身是同一函数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>似然函数本身也是一种概率</strong>，我们可以把$L(pH=0.5|HH)$写成$P(pH=0.5|HH)$; 而根据贝叶斯公式，$P(pH=0.5|HH) = {P(pH=0.5,HH)\over P(HH)}$；既然$HH$是已经发生的事件，理所当然$P(HH) = 1$,所以：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 在<strong>统计学</strong>中，我们关心的是在<strong>已知一系列投掷的结果时</strong>，关于硬币投掷时正面朝上的可能性的信息。<br>我们可以建立一个统计模型：假设硬币投出时会有$p_H$的概率正面朝上，而有$1-p_H$的概率反面朝上。<br>这时，条件概率可以改写成似然函数：</p>
<p>$L(p_H|HH)=P(HH|p_H=0.5)=0.25$</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 也就是说，对于取定的似然函数，在观测到两次投掷都是正面朝上时，$p_H=0.5$ 的<strong>似然性</strong>是0.25。如果考虑$p_H=0.6$，那么似然函数的值也会改变。</p>
<p>$L(p_H|HH)=P(HH|p_H=0.6)=0.36$ 注意到似然函数的值也变大了。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 这说明，如果参数$p_H$的取值变成0.6的话，结果观测到连续两次正面朝上的概率要比假设时$p_H=0.5$更大。也就是说，参数$p_H$取成0.6要比取成0.5更有说服力，更为“合理”。总之，<strong>似然函数的重要性不是它的具体取值，而是当参数变化时函数到底变小还是变大。</strong>对同一个似然函数，如果存在一个参数值，使得它的函数值达到最大的话，那么这个值就是最为“合理”的参数值。</p>
<p> &nbsp; &nbsp; &nbsp; 在这个例子中，似然函数实际上等于：</p>
<p>$L(\theta|HH)=P(HH|p_H=\theta)=\theta^2$ 其中$0 \le p_H\le 1$</p>
<p>如果取$p_H=1$ ，那么似然函数达到最大值1.也就是说，当连续观测到两次证明朝上时，假设硬币投掷正面朝上的概率为1是最合理的。</p>
<p>类似地，如果观测到三次投掷硬币，头两次正面朝上，第三次反面朝上，那么似然函数将会是</p>
<p>$L(\theta|HHT)=P(HHT|p_H=\theta)=\theta^2(1-\theta)$ ,其中$T$表示反面朝上，$0\le p_H \le 1$</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 这时候，似然函数的最大值将会在$p_H={2\over3}$的时候取到。也就是说，当观测到三次投掷中前两次正面朝上时，估计硬币投掷时正面朝上的概率$p_H={2\over 3}$是合理的。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 若一试验中有$n$个可能结果$A_1，A_2，…，A_n$,现在做一试验，若事件$A_i$发生了，则认为事件$A_i$在这$n$个可能结果中出现的概率最大。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 一次试验就出现的事件（应该）有较大的概率</p>
<p> &nbsp; &nbsp; &nbsp; <strong>极大似然估计</strong>就是在一次抽样中，若得到观测值$x_1,…,x_n$则选取$\hat\theta(x_1,…,x_n)$作为$\theta$的估计值。使得当$\theta=\hat\theta(x_1,…,x_n)$样本出现的概率最大。</p>
<p><strong>极大似然概率，就是在已知观测的数据的前提下，找到使得似然概率最大的参数值。</strong></p>
<ol>
<li><p><strong>若总体$X$为离散型</strong></p>
<p>设分布律$P{X=k}=p(x;\theta)$,$\theta$为待估参数，$\theta\in\Theta$ ,$X_1,X_2,…,X_n$是来自总体$X$的样本，若$x_1,x_2,…,x_n$为相对于$X_1,X_2,…,X_n$的样本值，<br>$L(\theta)=L(x_1,x_2,…,x_n;\theta)\prod p(x_i;\theta),\theta \in \Theta$</p>
</li>
</ol>
<p>$L(\theta)$称为样本似然函数</p>
<p>若$L(x_1,x_2,…,x_n;\hat\theta)  =  max_{\theta\in\Theta}  L(x_1,x_2,…,x_n;\theta)$  </p>
<p>$ \hat(x_1,x_2,\dots,x_n)$,参数$\theta$的极大似然估计值。</p>
<ol>
<li><strong>设总体$X$为连续型</strong></li>
</ol>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 设概率密度为$f(x;\theta),$$\theta$为待估参数， $\theta\in \Theta$,$X_1,x_2, \dots ,X_n$是 来自总体$X$的样本，若$x_1,x_2,\dots,x_n$为相应于$X_1,X_2,\dots,X_n$的样本值，</p>
<p>$$<br>L(\theta)=L(x_1,x_2,…,x_n;\theta)\prod f(x_i;\theta)<br>$$<br>$\hat \theta(x_1,x_2,\dots,x_n)$,参数$\theta$的极大似然估计值。</p>
<p>极大似然法求估计值的步骤：（一般情况下）</p>
<p>1）构造似然函数$L(\theta):$<br>$$<br>L(\theta)=\prod p(x_i;\theta)(离散型)<br>$$</p>
<p>$$<br>L(\theta)=\prod f(x_i;\theta)(离散型)<br>$$</p>
<p>2)取对数：$ln  L(\theta)$;</p>
<p>3)令 $d ln L  \over d\theta$=$0$;</p>
<p>4)解似然方程得到$\theta$ 的极大似然估计值$\hat\theta$</p>
<p><strong>说明</strong>：若似然方程（组）无解，或似然函数不可导，此法失效，改用其他方法。</p>
<p><strong>例1</strong>： 设$X$服从 参数$\lambda(\lambda&gt;0)$的泊松分布，$x_1,x_2,\dots,x_n$是来自于$X$的一个样本值,求$\lambda$的极大似然估计值</p>
<p><strong>解</strong>：因为$X$的分布律为</p>
<p>$P{X=x}$=${\lambda^x \over x! }e^{-\lambda}$, $(x=0,1,2,\dots,n)$</p>
<p>所以$\lambda$的似然函数为<br>$$<br>L(\lambda)=\prod_{i=1}^{n} ({\lambda ^{x_i} \over x_i!  }{e^{-\lambda}})=e^{-n\lambda}{\lambda^{\sum_{i=1}^nx_i}\over \prod_{i=1}^{n}(x_i!)}<br>$$</p>
<p>$$<br>ln  L(\lambda)  = -n\lambda+(\sum_{i=1}^{n}x_i)ln\lambda-\sum_{i=1}^{n}{(x_i!)},<br>$$</p>
<p>令${d\over{d \lambda}}lnL(\lambda)  = -n+{\sum_{i=1}^nx_i \over \lambda} = 0$</p>
<p>解得$\lambda$的极大似然估计值为$\hat\lambda={1\over n}\sum_{i=1}^nx_i=\overline x$</p>
<p>这有估计值与矩估计值是相同的。</p>
<p><strong>例2</strong>  设总体$X \sim N(\mu,\sigma^2)$,$\mu,\delta^2$为未知参数， $x_1,x_2,\dots,x_n$是来自$X$的一个样本值，求$\mu,\sigma^2$的极大似然估计值。</p>
<p><strong>解</strong>：$X$的概率密度为$f(x;\mu,\sigma^2)={1 \over \sqrt{2\pi}\sigma  }e^{-{(x-\mu)^2 \over 2\sigma^2}}$,</p>
<p>似然函数为<br>$$<br>L(\mu,\sigma ^2)= \prod_{i=1}^n{1 \over \sqrt{2\pi}}e{(x_i-\mu)^2 \over 2\sigma^2},<br>$$</p>
<p>$$<br>lnL(\mu,\sigma ^2)=-{n\over 2}ln(2\pi)-{n\over 2}ln\sigma^2-{1\over 2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2,<br>$$</p>
<p>令<br>$$</p>
<p>f(n) =<br>\begin{cases}<br>{\partial \over \partial\mu}lnL(\mu,\sigma^2)=0   \\<br>{\partial \over \partial\sigma^2}lnL(\mu,\sigma^2)=0   \\<br>\end{cases}</p>
<p>$$</p>
<p>$$<br>\begin{cases}<br>{1\over \sigma^2} [\sum_{i=1}^nx_i-n\mu]=0,\dots(1) \\<br>-{n\over 2\sigma^2}+{1\over (\sigma^2)^2}\sum_{i=1}^n(x_i-\mu)^2=0,\dots,(2)<br>\end{cases}<br>$$</p>
<p>故$\mu$和$\sigma^2$的 极大似然估计值为</p>
<p>&nbsp;$\hat\mu={1\over n}\sum_{i=1}^n\overline x$,$   \,\hat\sigma^2={1\over n}\sum_{i=1}^n(x_i-\overline x )$</p>
<p>这一估计值与矩估计值是相同的。</p>
<p><strong>例3</strong> 设总体$X$服从$[0,\theta]$上的均匀分布，$\theta&gt;0$未知，$x_1,x_2,\dots,x_n$是来自总体$X$的样本值，求出$\theta$的极大似然估计值。</p>
<p><strong>解</strong>：记$x_{(h)}=max(x_1,x_2,\dots,x_n)$,</p>
<p>$X$的概率密度为$f(x;\theta)=\begin{cases} {1\over \theta}, 0\le x \le \theta \\0,其他 \end{cases}$</p>
<p>所以似然函数为$L(\theta)=\begin{cases} {1\over \theta^n},x_{(h)} \le \theta \\0,其他 \end{cases}$</p>
<p>对于满足$x_{h}\le\theta$的任意$\theta$有</p>
<p>$$<br>L(\theta)={1\over\theta^n\le{1\over(x_{(h)})^n}}<br>$$</p>
<p>即似然函数$L(\theta)$在$\theta=x_h$时取得极大值，$\theta$的极大似然估计值为$\hat\theta=x_{(h)}=max_{1\le i\le n}x_i$</p>
<p>这一估计值与矩估计是不相同的。</p>
<p>###矩法估计值与极大似然估计值的比较</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">矩法估计法</th>
<th style="text-align:center">极大似然估计法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">依 据</td>
<td style="text-align:center">大数定律</td>
<td style="text-align:center">极大似然思想</td>
</tr>
<tr>
<td style="text-align:center">运 算</td>
<td style="text-align:center">较简单（可能会有信息量损失）</td>
<td style="text-align:center">较复杂</td>
</tr>
<tr>
<td style="text-align:center">精 度</td>
<td style="text-align:center">一般较低</td>
<td style="text-align:center">一般较高</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<p>1）矩法估计值与极大似然估计值不一定相同</p>
<p>2）不是所以极大似然估计法都需要建立似然方程求解。</p>
<p>​    最大似然估计是似然函数最初也是最自然的应用。上文已经提到，似然函数取得最大值表示相应的参数能够使得统计模型最为合理。从这样一个想法出发，最大似然估计的做法是：首先选取似然函数（一般是概率密度函数或概率质量函数），整理之后求最大值。实际应用中一般会取<strong>似然函数的对数作为求最大值的函数</strong>，这样求出的最大值和直接求最大值得到的结果是相同的。<strong>似然函数的最大值不一定唯一，也不一定存在</strong>。与矩法估计比较，最大似然估计的精确度较高，信息损失较少，但计算量较大。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就不难理解，在$data  mining$领域，许多求参数的方法最终都归结为最大化似然概率的问题。回到这个硬币的例子上来，在观测到$HH$的情况下，$pH = 1$$是最合理的（却未必符合真实情况，因为数据量太少的缘故）。</p>
<p>参考：</p>
<ol>
<li>极大似然估计法的原理和方法PPT</li>
</ol>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0</a></li>
<li><a href="http://www.cnblogs.com/zhsuiy/p/4822020.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhsuiy/p/4822020.html</a></li>
</ol>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title:  '极大似然估计法MLE',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client_id: &apos;de24b44123b8efbb4747&apos;,</span><br><span class="line">client_secret: &apos;785f51974278cde45a927a91a8438ef35eab9dd0&apos;,</span><br></pre></td></tr></table></figure>

  },
})
gitment.render('container')
</script>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[matplotlib-1学习]]></title>
      <url>/2018/02/02/matplotlib1/</url>
      <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">print(plt.plot([<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>第1句，这是导入Matplotlib接口的主要子模块pyplot绘图的首选格式。这是最好的做法，也是为了避免对全局名称空间的污染，强烈鼓励永远不要像这样导入接口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> &lt;module&gt; <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>第2句，此代码行是实际的绘图命令。我们只指定了一个值列表，这些值表示要绘制的点的垂直坐标。matplotlib将使用一个隐式的水平值列表，从0（前值）到n-1（n为列表中的条目数），纵轴表示Y轴，横坐标表示X轴。</p>
<p>第3句，这条命令实际上是打开包含绘图图像的窗口。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = range(<span class="number">6</span>)</span><br><span class="line">plt.plot(x, [xi**<span class="number">2</span> <span class="keyword">for</span> xi <span class="keyword">in</span> x])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="1-多线图"><a href="#1-多线图" class="headerlink" title="1.多线图"></a>1.多线图</h2><p>如果需要在一个图中画出多条线，我们只需要在show之前多次plot就可以了。Matplotlib会给每条线自动选择不同颜色。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">plt.plot(x, [xi*<span class="number">1.5</span> <span class="keyword">for</span> xi <span class="keyword">in</span> x])</span><br><span class="line">plt.plot(x, [xi*<span class="number">3.0</span> <span class="keyword">for</span> xi <span class="keyword">in</span> x])</span><br><span class="line">plt.plot(x, [xi/<span class="number">3.0</span> <span class="keyword">for</span> xi <span class="keyword">in</span> x])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>也可以写成下列形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, [xi*<span class="number">1.5</span> <span class="keyword">for</span> xi <span class="keyword">in</span> x], x, [xi*<span class="number">3.0</span> <span class="keyword">for</span> xi <span class="keyword">in</span> x], x,[xi/<span class="number">3.0</span> <span class="keyword">for</span> xi <span class="keyword">in</span> x])</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, x*<span class="number">1.5</span>, x, x*<span class="number">3.0</span>, x, x/<span class="number">3.0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2、网格"><a href="#2、网格" class="headerlink" title="2、网格"></a>2、网格</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.grid(<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3、坐标轴"><a href="#3、坐标轴" class="headerlink" title="3、坐标轴"></a>3、坐标轴</h2><p>你可能已经注意到，matplotlib为了精确地包含绘制的数据集自动设置图的界限。有时我们想自己设置坐标轴的界限。我们可以这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.py</span><br><span class="line">plot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> npx = np.arange(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">plt.plot(x, x*<span class="number">1.5</span>, x, x*<span class="number">3.0</span>, x, x/<span class="number">3.0</span>)</span><br><span class="line">print(plt.axis()) <span class="comment"># shows the current axis limits values，</span></span><br><span class="line"><span class="comment"># (0.85, 4.15, -0.25000000000000006, 12.583333333333334)</span></span><br><span class="line"><span class="comment"># plt.axis([0, 5, -1, 13]) 		# 	set new axes limits</span></span><br><span class="line"><span class="comment"># [0, 5, -1, 13]</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>如果axis()函数没有参数，它的返回值是实际的界限，有两种方式给这个函数传，一是通过四个值得列表[xmin, xmax, ymin, ymax] ，二是键值对的方式。</p>
<p>我们也可以只限制某个轴的最大值或者最小值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.axis(xmin=NNN, ymax=NNN)</span><br></pre></td></tr></table></figure>
<p>或者通过xlim()和ylim()函数只限制某一个坐标轴的界限。</p>
<h2 id="4、给坐标增加一个标签"><a href="#4、给坐标增加一个标签" class="headerlink" title="4、给坐标增加一个标签"></a>4、给坐标增加一个标签</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line">plt.xlabel(<span class="string">'This is the X axis'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'This is the Y axis'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="5、增加一个标题"><a href="#5、增加一个标题" class="headerlink" title="5、增加一个标题"></a>5、增加一个标题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">'Simple plot'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="6、增加图例"><a href="#6、增加图例" class="headerlink" title="6、增加图例"></a>6、增加图例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x, x*<span class="number">1.5</span>, label=<span class="string">'Normal'</span>)</span><br><span class="line">plt.plot(x, x*<span class="number">3.0</span>, label=<span class="string">'Fast'</span>)</span><br><span class="line">plt.plot(x, x/<span class="number">3.0</span>, label=<span class="string">'Slow'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure>
<h2 id="7、保存图到文件"><a href="#7、保存图到文件" class="headerlink" title="7、保存图到文件"></a>7、保存图到文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">'plot123.png'</span>)</span><br><span class="line">plt.savefig(<span class="string">'plot123.png'</span>, dpi=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<h2 id="8、Plot-支持可选的第三个参数"><a href="#8、Plot-支持可选的第三个参数" class="headerlink" title="8、Plot()支持可选的第三个参数"></a>8、Plot()支持可选的第三个参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(X, Y, <span class="string">'&lt;format&gt;'</span>, ...)</span><br></pre></td></tr></table></figure>
<p>plot方法的关键字参数color(或c)用来设置线的颜色。</p>
<p>控制颜色</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(y, <span class="string">'y'</span>)</span><br><span class="line">plt.plot(y+<span class="number">1</span>, <span class="string">'m'</span>)</span><br><span class="line">plt.plot(y+<span class="number">2</span>, <span class="string">'c'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>1）颜色的缩写</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Color abbreviation </strong></th>
<th style="text-align:center"><strong>Color Name </strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">blue</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">cyan</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">green</td>
</tr>
<tr>
<td style="text-align:center">k</td>
<td style="text-align:center">black</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">magenta</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">red</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">white</td>
</tr>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">yellow 2</td>
</tr>
</tbody>
</table>
<p>2）十六进制字符 #FF00FF</p>
<p>3）(r, g, b) 或 (r, g, b, a)，其中 r g b a 取均为[0, 1]之间</p>
<p>4）[0, 1]之间的浮点数的字符串形式，表示灰度值。0表示黑色，1表示白色</p>
<p>也可写成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x1, y1, fmt1, x2, y2, fmt2, ...)</span><br><span class="line">plt.plot(y, <span class="string">'y'</span>, y+<span class="number">1</span>, <span class="string">'m'</span>, y+<span class="number">2</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="9、控制线条样式"><a href="#9、控制线条样式" class="headerlink" title="9、控制线条样式"></a>9、控制线条样式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(y, <span class="string">'--'</span>, y+<span class="number">1</span>, <span class="string">'-.'</span>, y+<span class="number">2</span>, <span class="string">':'</span>)</span><br></pre></td></tr></table></figure>
<p>-  solid</p>
<p>–  dashed</p>
<p>-.  dashdot</p>
<p>:    dotted</p>
<p>‘’, ‘ ‘,    None</p>
<h2 id="10、控制标记样式"><a href="#10、控制标记样式" class="headerlink" title="10、控制标记样式"></a>10、控制标记样式</h2><table>
<thead>
<tr>
<th style="text-align:center"><strong>Marker abbreviation </strong></th>
<th style="text-align:center"><strong>Marker style </strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">Point marker</td>
</tr>
<tr>
<td style="text-align:center">,</td>
<td style="text-align:center">Pixel marker</td>
</tr>
<tr>
<td style="text-align:center">o</td>
<td style="text-align:center">Circle marker</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:center">Triangle down marker</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">Triangle up marker</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">Triangle left marker</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">Triangle right marker</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">Tripod down marker</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Tripod up marker</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Tripod left marker</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">Tripod right marker</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">Square marker</td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:center">Pentagon marker</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">Star marker</td>
</tr>
<tr>
<td style="text-align:center">h</td>
<td style="text-align:center">Hexagon marker</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">Rotated hexagon marker</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">Plus marker</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">Cross (x) marker</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">Diamond marker</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">Thin diamond marker</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>Vertical line (vline symbol) marker</td>
</tr>
<tr>
<td style="text-align:center">_</td>
<td style="text-align:center">Horizontal line (hline symbol) marker</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">y = np.arange(<span class="number">1</span>, <span class="number">3</span>, <span class="number">0.3</span>)</span><br><span class="line">plt.plot(y, <span class="string">'cx--'</span>, y+<span class="number">1</span>, <span class="string">'mo:'</span>, y+<span class="number">2</span>, <span class="string">'kp-.'</span>);</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>传递关键字参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">y = np.arange(<span class="number">1</span>, <span class="number">3</span>, <span class="number">0.3</span>)</span><br><span class="line">plt.plot(y, color=<span class="string">'blue'</span>, linestyle=<span class="string">'dashdot'</span>, linewidth=<span class="number">4</span>,</span><br><span class="line">marker=<span class="string">'o'</span>, markerfacecolor=<span class="string">'red'</span>, markeredgecolor=<span class="string">'black'</span>,</span><br><span class="line">markeredgewidth=<span class="number">3</span>, markersize=<span class="number">12</span>);</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>如果想画两条一样颜色的线，可以这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x1, y1, x2, y2, color=<span class="string">'green'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="11、X轴和Y轴的刻度"><a href="#11、X轴和Y轴的刻度" class="headerlink" title="11、X轴和Y轴的刻度"></a>11、X轴和Y轴的刻度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locs, labels = plt.xticks()</span><br></pre></td></tr></table></figure>
<p>不加任何参数的画，tick函数返回当前位置和标签，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(plt.xticks())</span><br><span class="line"><span class="comment">#(array([0. , 0.2, 0.4, 0.6, 0.8, 1. ]), &lt;a list of 6 Text xticklabel objects&gt;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line">x = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>] </span><br><span class="line">plt.plot(x); </span><br><span class="line">plt.xticks(range(len(x)), [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]); </span><br><span class="line">plt.yticks(range(<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>)); </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>使用字符来代表x的刻度</p>
<h2 id="12、中文字体不显示的问题"><a href="#12、中文字体不显示的问题" class="headerlink" title="12、中文字体不显示的问题"></a>12、中文字体不显示的问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"></span><br><span class="line">mpl.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'FangSong'</span>] <span class="comment"># 指定默认字体</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="keyword">False</span> <span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br></pre></td></tr></table></figure>
<p>参考：Matplotlib for python development</p>
<p>python中matplotlib的颜色及线条控制：<a href="http://blog.csdn.net/qq_26376175/article/details/67637151" target="_blank" rel="noopener">http://blog.csdn.net/qq_26376175/article/details/67637151</a></p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: 'matplotlib-1学习',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {

      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>]]></content>
      
        <categories>
            
            <category> matplot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> matplot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux-4：linux配置信息]]></title>
      <url>/2018/01/30/linux4/</url>
      <content type="html"><![CDATA[<h2 id="1-操作系统信息"><a href="#1-操作系统信息" class="headerlink" title="1.操作系统信息"></a>1.操作系统信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>
<h2 id="2-CPU相关信息"><a href="#2-CPU相关信息" class="headerlink" title="2.CPU相关信息"></a>2.CPU相关信息</h2><p>1) lscpu:显示CPU架构信息</p>
<p>$ lscpu</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Architecture:          x86_64</span><br><span class="line">CPU op-mode(s):        32-bit, 64-bit</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                4　　　　　　　　　　#总处理器核心数量(虚拟)</span><br><span class="line">On-line CPU(s) list:   0-3</span><br><span class="line">Thread(s) per core:    1　　　　　　　　　#每个核心支持的线程数量。1表示只支持一个线程，即不支持超线程</span><br><span class="line">Core(s) per socket:    1　　　　　　　　　#每个处理器的核心数量</span><br><span class="line">Socket(s):             4　　　　　　　　　#处理器数量</span><br><span class="line">NUMA node(s):          1</span><br><span class="line">Vendor ID:             GenuineIntel</span><br><span class="line">CPU family:            6   #CPU家族编号6</span><br><span class="line">Model:                 63     #代表处理器内部型号15</span><br><span class="line">Stepping:              0     </span><br><span class="line">CPU MHz:               2599.998</span><br><span class="line">BogoMIPS:              5199.99</span><br><span class="line">Hypervisor vendor:     VMware　　　　　　　#管理程序供应商</span><br><span class="line">Virtualization type:   full</span><br><span class="line">L1d cache:             32K</span><br><span class="line">L1i cache:             32K</span><br><span class="line">L2 cache:              256K</span><br><span class="line">L3 cache:              30720K</span><br><span class="line">NUMA node0 CPU(s):     0-3</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2)总核数 = 物理CPU个数 X 每颗物理CPU的核数</p>
<p>总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</p>
<p>查看物理CPU个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</span><br></pre></td></tr></table></figure>
<p>3)查看每个物理CPU中core的个数(即核数)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</span><br></pre></td></tr></table></figure>
<p>4)查看逻辑CPU的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</span><br></pre></td></tr></table></figure>
<p>5) 查看CPU信息（型号）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></figure>
<h2 id="3-内存信息"><a href="#3-内存信息" class="headerlink" title="3.内存信息"></a>3.内存信息</h2><p>查看当前系统的内存使用情况 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m    # 以M为单位，-g表示以G为单位</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>
<h2 id="4-硬盘信息"><a href="#4-硬盘信息" class="headerlink" title="4.硬盘信息"></a>4.硬盘信息</h2><p>1)lsblk：blk是block的缩写。列出块设备</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[xxx@localhost ~]$ lsblk</span><br><span class="line">NAME                        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0                          11:0    1 1024M  0 rom  </span><br><span class="line">sdb                           8:16   0  100G  0 disk </span><br><span class="line">└─sdb1                        8:17   0  100G  0 part /data</span><br><span class="line">sda                           8:0    0   60G  0 disk </span><br><span class="line">├─sda1                        8:1    0  500M  0 part /boot</span><br><span class="line">└─sda2                        8:2    0 59.5G  0 part </span><br><span class="line">  ├─VolGroup-lv_root (dm-0) 253:0    0   50G  0 lvm  /</span><br><span class="line">  ├─VolGroup-lv_swap (dm-1) 253:1    0    4G  0 lvm  [SWAP]</span><br><span class="line">  └─VolGroup-lv_home (dm-2) 253:2    0  5.6G  0 lvm  /home</span><br></pre></td></tr></table></figure>
<p>其中，TYPE=disk表示硬盘。可以看出，硬盘分为sda和sdb，一共160G。</p>
<p>2) df：查看硬盘使用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[xxx@localhost ~]$ df -h</span><br><span class="line">Filesystem                    Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/VolGroup-lv_root   50G  1.7G   46G   4% /</span><br><span class="line">tmpfs                         3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">/dev/sda1                     485M   39M  421M   9% /boot</span><br><span class="line">/dev/mapper/VolGroup-lv_home  5.5G  165M  5.1G   4% /home</span><br><span class="line">/dev/sdb1                      99G  188M   94G   1% /data</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/emanlee/p/3587571.html" target="_blank" rel="noopener">http://www.cnblogs.com/emanlee/p/3587571.html</a></p>
<p><a href="https://www.cnblogs.com/alwu007/p/6024631.html" target="_blank" rel="noopener">https://www.cnblogs.com/alwu007/p/6024631.html</a></p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: 'linux-4：linux配置信息',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {

      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>]]></content>
      
        <categories>
            
            <category> liunx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux-3：top命令]]></title>
      <url>/2018/01/26/linux3/</url>
      <content type="html"><![CDATA[<h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显示linux任务。top程序提供运行系统的动态实时视图。它可以显示系统概要信息以及当前由Linux内核管理的任务列表。所显示的系统摘要信息的类型以及任务所显示的信息的类型、顺序和大小都是用户可配置的，并且可以在重新启动时对该配置进行持久化。</p>
<h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top(选项)</span><br></pre></td></tr></table></figure>
<h2 id="3-常用选项"><a href="#3-常用选项" class="headerlink" title="3.常用选项"></a>3.常用选项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-b：以批处理模式操作；</span><br><span class="line">-c：显示完整的命令，例如使用的命令python test.py；</span><br><span class="line">-d：指定屏幕刷新间隔时间，并覆盖个人配置文件或启动默认值中的相应值， -d ss.tt (seconds.tenths)；</span><br><span class="line">-H：线程切换，当加上这个选项的时候，只会显示所有个人的显示</span><br><span class="line">-s：保密模式；</span><br><span class="line">-S：累积模式；</span><br><span class="line">-i&lt;时间&gt;：设置间隔时间；</span><br><span class="line">-u&lt;用户名&gt;：指定用户名，显示指定用户线程；</span><br><span class="line">-p&lt;进程号&gt;：指定进程；</span><br><span class="line">-n&lt;次数&gt;：循环显示的次数。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="4-top交互命令"><a href="#4-top交互命令" class="headerlink" title="4.top交互命令"></a>4.top交互命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">回车键或者空格键：刷新显示</span><br><span class="line">&quot;?&quot;或&quot;h&quot;：显示帮助画面，给出一些简短的命令总结说明；</span><br><span class="line">k：终止一个进程；</span><br><span class="line">i：忽略闲置和僵死进程，这是一个开关式命令；</span><br><span class="line">q：退出程序</span><br><span class="line">r：重新安排一个进程的优先级别；</span><br><span class="line">S：切换到累计模式；</span><br><span class="line">s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；</span><br><span class="line">m：切换显示内存信息；</span><br><span class="line">t：切换显示进程和CPU状态信息；</span><br><span class="line">c：切换显示命令名称和完整命令行；</span><br><span class="line">M：根据驻留内存大小进行排序；</span><br><span class="line">P：根据CPU使用百分比大小进行排序；p</span><br><span class="line">w：将当前设置写入~/.toprc文件中。</span><br></pre></td></tr></table></figure>
<h2 id="5-例子"><a href="#5-例子" class="headerlink" title="5.例子"></a>5.例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top - 09:44:56 up 16 days, 21:23,  1 user,  load average: 9.59, 4.75, 1.92</span><br><span class="line">Tasks: 145 total,   2 running, 143 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s): 99.8%us,  0.1%sy,  0.0%ni,  0.2%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:   4147888k total,  2493092k used,  1654796k free,   158188k buffers</span><br><span class="line">Swap:  5144568k total,       56k used,  5144512k free,  2013180k cached</span><br></pre></td></tr></table></figure>
<ul>
<li>top - 09:44:56[当前系统时间],</li>
</ul>
<ul>
<li>16 days[系统已经运行了16天],</li>
<li>1 user[个用户当前登录],</li>
<li>load average: 9.59, 4.75, 1.92[系统负载，即任务队列的平均长度]</li>
<li>Tasks: 145 total[总进程数],</li>
<li>2 running[正在运行的进程数],</li>
<li>143 sleeping[睡眠的进程数],</li>
<li>0 stopped[停止的进程数],</li>
<li>0 zombie[冻结进程数],</li>
<li>Cpu(s): 99.8%us[用户空间占用CPU百分比],</li>
<li>0.1%sy[内核空间占用CPU百分比],</li>
<li>0.0%ni[用户进程空间内改变过优先级的进程占用CPU百分比],</li>
<li>0.2%id[空闲CPU百分比], 0.0%wa[等待输入输出的CPU时间百分比],</li>
<li>0.0%hi[硬中断（Hardware IRQ）占用CPU的百分比],</li>
<li>0.0%si [] 软中断（Software Interrupts）占用CPU的百分比]</li>
<li>0.0%st[],</li>
<li>Mem: 4147888k total[物理内存总量],</li>
<li>2493092k used[使用的物理内存总量],</li>
<li>1654796k free[空闲内存总量],</li>
<li>158188k buffers[用作内核缓存的内存量]</li>
<li>Swap:  5144568k total[交换区总量],</li>
<li>56k used[使用的交换区总量],</li>
<li>5144512k free[空闲交换区总量],</li>
<li>2013180k cached[缓冲的交换区总量],</li>
</ul>
<p><img src="/2018/01/26/linux3/a.png" alt="top命令视图"></p>
<ul>
<li>PID 进程id</li>
<li>USER 进程所有者</li>
<li>PR 进程优先级</li>
<li>NI nice值。负值表示高优先级，正值表示低优先级</li>
<li>VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li>
<li>RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li>
<li>SHR 共享内存大小，单位kb</li>
<li>S 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li>
<li>%CPU 上次更新到现在的CPU时间占用百分比</li>
<li>%MEM 进程使用的物理内存百分比</li>
<li>TIME+ 进程使用的CPU时间总计，单位1/100秒</li>
<li>COMMAND 进程名称（命令名/命令行）</li>
</ul>
<p><strong>注意</strong>：TIME+代表的是进程使用CPU的时间，不是进程启动到现在的时间。因此，如果一个人进程使用CPU的时间很少，即使这个进程已经存在很长时间了，TIME+也是个很小的数值。如果使用多个CPU或者是多核的CPU，那么这个时间是多个CPU的时间的和。例如16:39.33,表示16分钟39秒十分之3秒百分之3秒。</p>
<p><a href="http://man.linuxde.net/top" target="_blank" rel="noopener">http://man.linuxde.net/top</a></p>
<p><a href="https://www.cnblogs.com/ronli/p/centos-top.html" target="_blank" rel="noopener">https://www.cnblogs.com/ronli/p/centos-top.html</a></p>
<p><a href="https://linux.die.net/man/1/top" target="_blank" rel="noopener">https://linux.die.net/man/1/top</a></p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: 'linux-3：top命令',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {

      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>















]]></content>
      
        <categories>
            
            <category> liunx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[errors1]]></title>
      <url>/2018/01/23/errors1/</url>
      <content type="html"><![CDATA[<p>​    今天又遇到换行符的错误。想起以前换行符中遇到的坑。在不同的操作系统默认的换行符不一样，字符处理的时候会遇到一些莫名奇妙的问题。windows的换行是\r\n，linux的是\n，mac的是\r。在网络编程中，如果把Windows的一个文件数据传输到linux系统中的另一个文件，如果计算两个文件的字节数会发现两个系统同样的文本数据字节数会不一样。就是因为换行符导致的，通常模式下，换行符，空格等都是空白符，不可见的。在notepad++中视图显示所有字符会发现Windows中的换行符为CRLF，而linux中换行符为LF。利用notepad++可以将Windows文本文件转换为unix格式的文件。</p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id:  'window.location.pathname', // 可选。默认为 location.href
  title:  'errors1',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {

      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>]]></content>
      
        <categories>
            
            <category> error </category>
            
        </categories>
        
        
        <tags>
            
            <tag> errors </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[markdown学习]]></title>
      <url>/2018/01/23/markdown/</url>
      <content type="html"><![CDATA[<p>special symbol in markdown</p>
<p><a href="http://www.math.harvard.edu/texman/node21.html#SECTION00084000000000000000" target="_blank" rel="noopener">http://www.math.harvard.edu/texman/node21.html#SECTION00084000000000000000</a></p>
<h2 id="1-空白类型列举"><a href="#1-空白类型列举" class="headerlink" title="1.空白类型列举"></a>1.空白类型列举</h2><table>
<thead>
<tr>
<th style="text-align:center">两个quad空格</th>
<th style="text-align:center">a \qquad b</th>
<th style="text-align:center">ab</th>
<th style="text-align:center">两个<em>m</em>的宽度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">quad空格</td>
<td style="text-align:center">a \quad b</td>
<td style="text-align:center">ab</td>
<td style="text-align:center">一个<em>m</em>的宽度</td>
</tr>
<tr>
<td style="text-align:center">大空格</td>
<td style="text-align:center">a b</td>
<td style="text-align:center">a b</td>
<td style="text-align:center">1/3<em>m</em>宽度</td>
</tr>
<tr>
<td style="text-align:center">中等空格</td>
<td style="text-align:center">a\;b</td>
<td style="text-align:center">ab</td>
<td style="text-align:center">2/7<em>m</em>宽度</td>
</tr>
<tr>
<td style="text-align:center">小空格</td>
<td style="text-align:center">a\,b</td>
<td style="text-align:center">ab</td>
<td style="text-align:center">1/6<em>m</em>宽度</td>
</tr>
<tr>
<td style="text-align:center">没有空格</td>
<td style="text-align:center">ab</td>
<td style="text-align:center">ab</td>
<td style="text-align:center">正常宽度</td>
</tr>
<tr>
<td style="text-align:center">紧贴</td>
<td style="text-align:center">a!b</td>
<td style="text-align:center">ab</td>
<td style="text-align:center">缩进1/6<em>m</em>宽度</td>
</tr>
</tbody>
</table>
<p>偏导 \partial $ \partial$</p>
<a id="more"></a>
<h2 id="2-希腊字母"><a href="#2-希腊字母" class="headerlink" title="2.希腊字母"></a>2.希腊字母</h2><table>
<thead>
<tr>
<th style="text-align:center">输入</th>
<th style="text-align:center">显示</th>
<th style="text-align:center">输入</th>
<th style="text-align:center">显示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>$\alpha$</code></td>
<td style="text-align:center">αα</td>
<td style="text-align:center"><code>$A$</code></td>
<td style="text-align:center">AA</td>
</tr>
<tr>
<td style="text-align:center"><code>$\beta$</code></td>
<td style="text-align:center">ββ</td>
<td style="text-align:center"><code>$B$</code></td>
<td style="text-align:center">BB</td>
</tr>
<tr>
<td style="text-align:center"><code>$\gamma$</code></td>
<td style="text-align:center">γγ</td>
<td style="text-align:center"><code>$\Gamma$</code></td>
<td style="text-align:center">ΓΓ</td>
</tr>
<tr>
<td style="text-align:center"><code>$\delta$</code></td>
<td style="text-align:center">δδ</td>
<td style="text-align:center"><code>$\Delta$</code></td>
<td style="text-align:center">ΔΔ</td>
</tr>
<tr>
<td style="text-align:center"><code>$\epsilon$</code></td>
<td style="text-align:center">ϵϵ</td>
<td style="text-align:center"><code>$E$</code></td>
<td style="text-align:center">EE</td>
</tr>
<tr>
<td style="text-align:center"><code>$\zeta$</code></td>
<td style="text-align:center">ζζ</td>
<td style="text-align:center"><code>$Z$</code></td>
<td style="text-align:center">ZZ</td>
</tr>
<tr>
<td style="text-align:center"><code>$\eta$</code></td>
<td style="text-align:center">ηη</td>
<td style="text-align:center"><code>$H$</code></td>
<td style="text-align:center">HH</td>
</tr>
<tr>
<td style="text-align:center"><code>$\theta$</code></td>
<td style="text-align:center">θθ</td>
<td style="text-align:center"><code>$\Theta$</code></td>
<td style="text-align:center">ΘΘ</td>
</tr>
<tr>
<td style="text-align:center"><code>$\iota$</code></td>
<td style="text-align:center">ιι</td>
<td style="text-align:center"><code>$I$</code></td>
<td style="text-align:center">II</td>
</tr>
<tr>
<td style="text-align:center"><code>$\kappa$</code></td>
<td style="text-align:center">κκ</td>
<td style="text-align:center"><code>$K$</code></td>
<td style="text-align:center">KK</td>
</tr>
<tr>
<td style="text-align:center"><code>$\lambda$</code></td>
<td style="text-align:center">λλ</td>
<td style="text-align:center"><code>$\Lambda$</code></td>
<td style="text-align:center">ΛΛ</td>
</tr>
<tr>
<td style="text-align:center"><code>$\nu$</code></td>
<td style="text-align:center">νν</td>
<td style="text-align:center"><code>$N$</code></td>
<td style="text-align:center">NN</td>
</tr>
<tr>
<td style="text-align:center"><code>$\mu$</code></td>
<td style="text-align:center">μμ</td>
<td style="text-align:center"><code>$M$</code></td>
<td style="text-align:center">MM</td>
</tr>
<tr>
<td style="text-align:center"><code>$\xi$</code></td>
<td style="text-align:center">ξξ</td>
<td style="text-align:center"><code>$\Xi$</code></td>
<td style="text-align:center">ΞΞ</td>
</tr>
<tr>
<td style="text-align:center"><code>$o$</code></td>
<td style="text-align:center">oo</td>
<td style="text-align:center"><code>$O$</code></td>
<td style="text-align:center">OO</td>
</tr>
<tr>
<td style="text-align:center"><code>$\pi$</code></td>
<td style="text-align:center">ππ</td>
<td style="text-align:center"><code>$\Pi$</code></td>
<td style="text-align:center">ΠΠ</td>
</tr>
<tr>
<td style="text-align:center"><code>$\rho$</code></td>
<td style="text-align:center">ρρ</td>
<td style="text-align:center"><code>$P$</code></td>
<td style="text-align:center">PP</td>
</tr>
<tr>
<td style="text-align:center"><code>$\sigma$</code></td>
<td style="text-align:center">σσ</td>
<td style="text-align:center"><code>$\Sigma$</code></td>
<td style="text-align:center">ΣΣ</td>
</tr>
<tr>
<td style="text-align:center"><code>$\tau$</code></td>
<td style="text-align:center">ττ</td>
<td style="text-align:center"><code>$T$</code></td>
<td style="text-align:center">TT</td>
</tr>
<tr>
<td style="text-align:center"><code>$\upsilon$</code></td>
<td style="text-align:center">υυ</td>
<td style="text-align:center"><code>$\Upsilon$</code></td>
<td style="text-align:center">ΥΥ</td>
</tr>
<tr>
<td style="text-align:center"><code>$\phi$</code></td>
<td style="text-align:center">ϕϕ</td>
<td style="text-align:center"><code>$\Phi$</code></td>
<td style="text-align:center">ΦΦ</td>
</tr>
<tr>
<td style="text-align:center"><code>$\chi$</code></td>
<td style="text-align:center">χχ</td>
<td style="text-align:center"><code>$X$</code></td>
<td style="text-align:center">XX</td>
</tr>
<tr>
<td style="text-align:center"><code>$\psi$</code></td>
<td style="text-align:center">ψψ</td>
<td style="text-align:center"><code>$\Psi$</code></td>
<td style="text-align:center">ΨΨ</td>
</tr>
<tr>
<td style="text-align:center"><code>$\omega$</code></td>
<td style="text-align:center">ωω</td>
<td style="text-align:center"><code>$\Omega$</code></td>
<td style="text-align:center">ΩΩ</td>
</tr>
</tbody>
</table>
<h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h2><ul>
<li><strong>省略号 </strong>：\ldots 表示与文本底线对齐的省略号，\cdots 表示与文本中线对齐的省略号。</li>
<li><code>()</code>、<code>[]</code>和<code>|</code>表示符号本身，使用 <code>\{\}</code> 来表示 <code>{}</code>。当要显示大号的括号或分隔符时，要用 <code>\left</code> 和 <code>\right</code> 命令。</li>
</ul>
<p>一些特殊的括号：</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>显示</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$$\langle表达式\rangle$$</code></td>
<td>⟨表达式⟩⟨表达式⟩</td>
</tr>
<tr>
<td><code>$$\lceil表达式\rceil$$</code></td>
<td>⌈表达式⌉⌈表达式⌉</td>
</tr>
<tr>
<td><code>$$\lfloor表达式\rfloor$$</code></td>
<td>⌊表达式⌋⌊表达式⌋</td>
</tr>
<tr>
<td><code>$$\lbrace表达式\rbrace$$</code></td>
<td>{表达式}{表达式}</td>
</tr>
</tbody>
</table>
<p>例子：<br><code>$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</code></p>
<p>$f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)$</p>
<ul>
<li><strong>分数</strong>：通常使用 <code>\frac {分子} {分母}</code>命令产生一个分数\frac {分子} {分母}，分数可嵌套。</li>
</ul>
<p>便捷情况可直接输入 <code>\frac ab</code>来快速生成一个\frac ab。<br>如果分式很复杂，亦可使用 分子 \over 分母 命令，此时分数仅有一层。</p>
<p>参考：<a href="https://www.cnblogs.com/q735613050/p/7253073.html" target="_blank" rel="noopener">https://www.cnblogs.com/q735613050/p/7253073.html</a></p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: 'markdown学习',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {

      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>





























]]></content>
      
        <categories>
            
            <category> markdown </category>
            
        </categories>
        
        
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[序列标注-3：CRF介绍]]></title>
      <url>/2018/01/23/ner3/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想象一下，你有来自贾斯汀·比伯的一天生活的的一系列快照，你想用它所代表的活动（吃饭、睡觉、开车等）来标记每个图像。你会怎么做？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种方法是忽略快照的顺序性质，并构建一个图像分类器。例如，给定一个月的被标记的快照，你可能知道，黑暗拍摄的图像往往是在早上睡觉，有耀眼的色彩图像往往是跳舞，汽车的图像往往在驾驶，等等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，忽略这个连续的方面，你会失去很多信息。例如，如果你看到一张嘴巴的特写照片是关于唱歌还是吃饭？如果你知道前一张图片是贾斯汀·比伯吃或做饭的照片，那么这张照片更有可能是关于吃的；如果，前一张图片包含贾斯汀·比伯唱歌或跳舞，那么这张照片可能暗示他在唱歌。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，为了增加我们的标注的精度，我们应该结合它附近的照片的标签，而这正是一个条件随机场所能做的。</p>
<h2 id="1-词性标注"><a href="#1-词性标注" class="headerlink" title="1.词性标注"></a>1.词性标注</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们使用更为常见的词性标注示例来进一步研究一些细节。在词性标注中，目标是用ADJECTIVE、 NOUN、PREPOSITION、VERB、ADVERB、ARTICLE等标签来标记句子（单词或记号的序列）。例如，对于句子“Bob drank coffee at Starbucks”，标注为”Bob (NOUN) drank (VERB) coffee (NOUN) at (PREPOSITION) Starbucks (NOUN)”。我们建立一个条件随机场对句子进行词性标注。就像任何的分类器，我们首先需要选择一组特征函数。</p>
<a id="more"></a>
<h2 id="2-CRF中的特征函数"><a href="#2-CRF中的特征函数" class="headerlink" title="2.CRF中的特征函数"></a>2.CRF中的特征函数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在CRF中，每个特征函数都是采用以下特征作为输入，以实数为输出（一般是0或者1）</p>
<ul>
<li>一个句子</li>
<li>句子的第i个字</li>
<li>当前字的标签</li>
<li>前一个字的特征</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：通过限制我们的特性依赖于当前和以前的标签，而不是整个句子中的任意标签，我实际上构建了一个特殊的线性链CRF，这里将忽略一般的CRF。例如，一个可能的特征函数可以衡量在前一个字为“very”的情况下，当前单词应该被标记为一个形容词。</p>
<h2 id="3-特征到概率"><a href="#3-特征到概率" class="headerlink" title="3.特征到概率"></a>3.特征到概率</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来给每个特征函数$f_j$一个权重$\lambda_j$ （我们将会讨论怎么从数据中学习到这些权重）。对于给定的一个句话，我们现在可以累加句中所有字加权后的特征来得到标签序列$l$的分数：</p>
<p>$score(l|s)=\sum_{j=1=0}^m \sum_{i=1}^n \lambda_j f_j(s,i,l_i,l_{i-1})$</p>
<p>第一个求和是对每个特征函数，里面的求和是对句子的每个字。</p>
<p>最后，我们可以将这些得分通过指数函数然后归一化转换成在0到1之间的概率$p(l|s)$</p>
<p>$p(l|s)=$ $exp[score(l|s) \over \sum_{ l’}exp[score(l’|s)] $ =$exp[\sum_{j=1}^m \sum_{i=1}^n \lambda_j f_j (s,i,l_i,l_{i-1})  ]\over \sum_{ l’}exp[\sum_{j=1}^m \sum_{i=1}^n \lambda_j f_j (s,i,l_i,l_{i-1}) ] $ </p>
<h2 id="4-特征函数举例"><a href="#4-特征函数举例" class="headerlink" title="4.特征函数举例"></a>4.特征函数举例</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;词性标注中，可以包含以下特征：</p>
<ul>
<li>$f_1(s,i,l_i,l_{i-1})=1 \: $ 如果$\: l_i=ADVERB$ 和第$i$个词以“-ly”结尾;否则，特征函数为0。如果和这个特征关联的权重$\lambda_1$是大的正数，这个特征表明我们倾向于把以“-ly”结尾的词标注为“ADVERB”。</li>
<li>$f_2(s,i,l_i,l_{i-1})=1 \: $ 如果$ i=1,\: l_i=VERB$ 和这个句子一问号结尾时。否则，特征函数为0。同样，如果该特征的权重值$\lambda_2$ 为大的正数，就偏向于将问句里的第一个词标为VERB（例如 “Is this a sentence beginning with a verb?”）</li>
<li>$f_3(s,i,l_i,l_{i-1})=1 \: $ 如果$l_{i-1}=ADJECTIVE$ 和$l_i=NOUN$。否则特征函数为0。同样的，一个正数意味着“NOUN”跟着“ADJECTIVE”后面。</li>
<li>$f_3(s,i,l_i,l_{i-1})=1 \: $如果$l_{i-1}=PERPOSITION $和 $l_1=PERPOSTION$。一个负的权重$\lambda_4$对这个特征函数意味着“prepostion”后面不太可能跟着“preposition”，所以我们应该避免这种标签的产生。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是全部。总的来说，为了建立一个条件随机场，你只需要定义一系列的特征函数（依赖整个句子，当前位置，和附近的标签），给它们赋上对应的权重，然后对它们求和。如果需要的话，在最后把它们变成概率。</p>
<p>现在让我们回到前面并且比较一下CRF和其他类似的机器学习方法。</p>
<h2 id="5-看起来像逻辑回归"><a href="#5-看起来像逻辑回归" class="headerlink" title="5.看起来像逻辑回归"></a>5.看起来像逻辑回归</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CRF的概率形式$p(l|s)=$$exp[\sum_{j=1}^m \sum_{i=1}^n \lambda_j f_j (s,i,l_i,l_{i-1})  \over \sum_{ l’}exp[\sum_{j=1}^m \sum_{i=1}^n \lambda_j f_j (s,i,l_i,l_{i-1})] $ 看起来有些熟悉。这是因为CRF是逻辑回归的序列化版本：逻辑回归是一个用于分类的对数线性模型，CRF是一个用于序列标注的对数线性模型。</p>
<h2 id="6-看起来像隐马尔可夫模型"><a href="#6-看起来像隐马尔可夫模型" class="headerlink" title="6.看起来像隐马尔可夫模型"></a>6.看起来像隐马尔可夫模型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回忆隐马尔可夫模型是另外一个用于词性标注的模型。CRF是计算一系列特征函数的得分，而HMM是一个用于序列标注的生成式模型。定义</p>
<ul>
<li>$p(l,s)=p(l_1)\prod p(l_i|l_{i-1}) p(w_i|l_i)) $</li>
<li>$p(l_i|l_{i-1})$ 是转移概率（例如，介词后面是名词的概率）</li>
<li>$p(w_i|l_i)$ 是发射概率（例如，“dad”是名词的概率）</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CRF跟HMM比较怎么样？CRF更强大，它可以建模所有HMM能建模的，甚至更多。下面举个例子：</p>
<p>注意到HMM的对数形式为$log\:p(l,s)=log\:p(l_0)+\sum_{i}\:log\:p(l_i|l_{i-1})+\sum_i\:p(w_i|l_i)$ 。如果我们考虑这些对数概率为关联二进制的转移和发射特征的权重。这实际上是CRF的一个对数线性形式。</p>
<p>这样，我们就可以通过一些方式建立一个与HMM等价的CRF模型：</p>
<ol>
<li>对HMM中的每个转移概率$p(l_i=y|l_{i-1}=x)$ ,定义一个人转移特征$f_{x,y}(s,i,l_i,l_{i-1})=1$ if $l_i=y\: and\:l_{i-1}=x$ 。给每个特征一个权重$w_{x,y}=log\:p(l_i=y|l_{i-1}=x)$ 。</li>
<li>类似地，对每个发射概率$p(w_i=z|l_i=x)$ 定义系列特征$g_{x,y}(s,i,l_i,l_{i-1})=1\:if \: w_i=z\:and \: l_i=x$ 。给每个特征一个权重$w_{x,z}=log\:p(w_i=z|l_i=x)$ 。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，$p(l|s)$ 通过CRF这些特征计算得到的分数与HMM计算的分数是成比例的，所有每个HMM都等价某个CRF。</p>
<p>然而，因为以下两个原因，CRF可以对更丰富的标签分布建模。</p>
<ol>
<li>CRF可以定义更大的特征集合。HMM本质是局部的（因为被限制到转移特征函数和发射特征函数，这些函数要求，每个词只取决于当前的标签，每个标签只依赖前一个标签），但是CRF可以使用更多的全局特征。以词性标注的一个特征为例，如果句子以问号结尾，这个词被标注为“VERB”的概率会增加。</li>
<li>CRF可以有任意的权重。HMM的概率必须满足某种约束（例如，$0&lt;=p(w_i|l_i)&lt;=1,\sum_{w} p(w_i=w|l_i)=1$）,但是CRF中的权重不受限制（例如$log\:p(w_i|l_i)$ 可以是任意的）</li>
</ol>
<h2 id="7-权重的学习"><a href="#7-权重的学习" class="headerlink" title="7.权重的学习"></a>7.权重的学习</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们回到如何学习CRF的权重这个问题。毫无疑问的一种方式是使用梯度下降。假设我们有一系列的训练实例（被词性标注的句子）。随机初始化我们CRF模型中的权重。为了调整这些随机初始化的权重到正确的权重，对于每一个训练实例：</p>
<ol>
<li>遍历每一个特征函数，然后对$\lambda_i$ 计算每一个训练实例对数概率的梯度。</li>
</ol>
<p>${\partial} \over { \partial w_j} $$log\:p(l|s)=\sum_{j=1}^m f_i(s,j,l_j,l_{j-1})-\sum_{l’} \:p(l’|s)\sum_{j=1}^m f_i(s,j,l’_j,l’_{j-1} )$</p>
<ol>
<li>注意梯度中的第一项是特征$f_i$ 在正确标注下的贡献，第二项是特征$f_i$在当前模型中的贡献。这就是你所期望采用的梯度上升公式。</li>
<li>将$\lambda_i$ 朝着梯度下降的方向移动：$ \lambda_i =  \lambda_i+\alpha[\sum_{j=1}^m f_i(s,j,l_{j},l_{j-1})-\sum_l’p(l’|s)\sum_{j=1}^{m} f_{i}(s,j,l_{j}^{‘},l_{j-1}^{‘})]$</li>
<li>重复以上步骤直到停止条件（例如 更新低于某个阈值）。</li>
</ol>
<p>换句话说，每一个步骤都在学习我们想要的模型和当前模型的状态的差异，然后使$\lambda_i$沿着这个差异的方向移动</p>
<h2 id="8-找到最优标注"><a href="#8-找到最优标注" class="headerlink" title="8.找到最优标注"></a>8.找到最优标注</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们已经训练好了我们的CRF模型，现在有一个新的句子，我们怎么对它进行标注呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最简单的方式是对每个可能标签序列计算$p(l|s)$ ，然后选择是这个概率最大的标签序列。然而，对于有k种标签的集合和长度为m的句子，就会有$k^m$ 种可能的标签序列，时间复杂度是指数型。一个更好的方式是意识到线性链CRF满足最优化子结构性质，可以使用动态规划算法（多项式复杂度）找到最优标签序列，与隐马尔可夫模型中的维特比算法类似。</p>
<h2 id="9-一个更有趣的应用"><a href="#9-一个更有趣的应用" class="headerlink" title="9.一个更有趣的应用"></a>9.一个更有趣的应用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;词性标注有些无聊，已经有很多词性标注器。什么时候会在生活中使用CRF呢？</p>
<p>假设你想从推特上挖掘人们在圣诞节上到礼物类型,你怎么知道哪些词是指礼物？</p>
<p>为了收集数据，我只是简单地寻找“我想要圣诞节balabala”和“我在圣诞节得到balabala”的短语。然而，一个更复杂的CRF的变种可以使用GIFT作为词性标注的一部分（甚至添加其他标签如gift-giver和gift-receiver，获得更多的信息，谁得到来自谁的东西），像对待一个词性标注问题。特征可以基于诸如如果前面的字是一个”gift-receiver”并且这个字之前是“gave“这个词是一个礼物或者如果这个词接下来的两个词是“for Christmas”，这个词也是一个礼物。</p>
<p>翻译自<a href="http://blog.echen.me/2012/01/03/introduction-to-conditional-random-fields/" target="_blank" rel="noopener">http://blog.echen.me/2012/01/03/introduction-to-conditional-random-fields/</a></p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: '序列标注-3：CRF介绍',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {
      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>

































]]></content>
      
        <categories>
            
            <category> ner </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ner </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux-2：用户目录下的配置文件]]></title>
      <url>/2018/01/22/linux2/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Ubuntu服务器的用户目录下，有以下几个文件：</p>
<ol>
<li>.bash_history</li>
<li>.bash_logout</li>
<li>.bashrc</li>
<li>.profile</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“.”开头的文件都是隐藏文件。Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux 的 Shell 种类众多，常见的有：</p>
<ul>
<li><p>Bourne Shell（/usr/bin/sh或/bin/sh）</p>
</li>
<li><p>Bourne Again Shell（/bin/bash）</p>
</li>
<li><p>C Shell（/usr/bin/csh）</p>
</li>
<li><p>K Shell（/usr/bin/ksh）</p>
</li>
<li><p>Shell for Root（/sbin/sh）</p>
<a id="more"></a>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bash（ Bourne Again Shell） 是一个可执行从标准输入或者文件中读取的命令的一种兼容sh命令语言解释器。Bash集成了来自K Shell和C Shell的实用功能。Bash是与Shell和IEEE POSIX规范一致的一种实现。Bash是POSIX的默认配置。Bash 也是大多数Linux 系统默认的 Shell。</p>
<p>通过以下命令查看文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man bash</span><br></pre></td></tr></table></figure>
<h2 id="1-bashrc"><a href="#1-bashrc" class="headerlink" title="1. ~/.bashrc"></a>1. ~/.bashrc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The individual per-interactive-shell startup file   # 个人交互式shell的启动文件。</span><br></pre></td></tr></table></figure>
<p>这个文件类似于windows系统的环境变量的设置，如命令别名、路径等。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PATH=&quot;/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin&quot;</span><br><span class="line">LANG=zh_CN.GBK</span><br><span class="line">export PATH LANG</span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">alias ls=&apos;/bin/ls -F --color=tty --show-control-chars&apos;</span><br></pre></td></tr></table></figure>
<p>​    例子中定义了路径，语言，命令别名（使用rm删除命令时总是加上-i参数需要用户确认，使用ls命令列出文件列表时加上颜色显示）。每次修改.bashrc后，使用source ~/.bashrc（或者 . ~/.bashrc）就可以立刻加载修改后的设置，使之生效。一般会在.bash_profile文件中显式调用.bashrc。登陆linux启动bash时首先会去读取~/.bash_profile文件，这样~/.bashrc也就得到执行了，你的个性化设置也就生效了。</p>
<h2 id="2-profile"><a href="#2-profile" class="headerlink" title="2.~/.profile"></a>2.~/.profile</h2><p>同样是配置文件。如果~/.bash_profile 或者 ~/.bash_login存在，这个文件不会被bash读取。</p>
<h2 id="3-bash-logout"><a href="#3-bash-logout" class="headerlink" title="3.~/bash_logout"></a>3.~/bash_logout</h2><p>当login Shell 存在的时候会被执行。当离开控制台的时候，清除屏幕以增加隐私性。</p>
<h2 id="4-bash-history"><a href="#4-bash-history" class="headerlink" title="4.~/bash_history"></a>4.~/bash_history</h2><p>记录命令的历史记录。</p>
<p>在根目录下也有一个bashrc，/etc/bashrc:为每一个运行bash shell的用户执行此文件。当bash shell被打开时,该文件被读取。~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该<br>该文件被读取。而在系统加载的过程中，通过/etc/init调用/etc/inittab，调用/etc/rc.d/rc.sysinit和/etc/rc.d/init.d/functions，然后启动和检查系统功能和服务。在启动bash时，分别再调用/etc/profile和/etc/bashrc，而对于每个用户，在打开shell时使用HOME/.bashrc和​HOME/.bash_profile设定专用于自己使用的shell信息。普通用户只能更改用户目录下的配置文件，跟目录下的配置文件只有可读的权限。</p>
<p>登陆时执行文件的顺序是：</p>
<ol>
<li>/etc/profile</li>
<li>user home directory /.bash_profile</li>
<li>user home directory /.bash_login</li>
<li>user home directory /.profile</li>
</ol>
<p>参考：</p>
<p><a href="http://blog.csdn.net/yeqishi/article/details/5652870" target="_blank" rel="noopener">http://blog.csdn.net/yeqishi/article/details/5652870</a></p>
<p><a href="http://blog.csdn.net/decisiveness/article/details/51967721" target="_blank" rel="noopener">http://blog.csdn.net/decisiveness/article/details/51967721</a></p>
<p><a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-shell.html</a></p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: 'linux-2：用户目录下的配置文件',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {

      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>







]]></content>
      
        <categories>
            
            <category> liunx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux-1:源码安装]]></title>
      <url>/2018/01/18/linux/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在linux系统中，源码的安装一般有3个步骤组成：配置（configure）、源码（make）、安装（make install），具体的安装方法一般作者都会给出文档，这里主要讨论配置（configure）。Configure是一个可执行脚本，它有很多选项，使用命令./configure –help输出详细的选项列表，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-bash-3.00# ./configure --help</span><br><span class="line">Usage: configure [options][ host]</span><br><span class="line">Options: [defaults in brackets after descriptions]</span><br><span class="line">Configuration:</span><br><span class="line">--cache-file=FILE     cache test results in FILE</span><br><span class="line">--help             print this message</span><br><span class="line">--no-create         do not create output files</span><br><span class="line">--quiet, --silent     do not print `checking...&apos; messages</span><br><span class="line">--version           print the version of autoconf that created configure</span><br><span class="line">Directory and file names:</span><br><span class="line">--prefix=PREFIX       install architecture-independent files in PREFIX [/usr/local]</span><br><span class="line">--exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX [same as prefix]</span><br><span class="line">--bindir=DIR         user executables in DIR [EPREFIX/bin]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中–prefix选项就是配置安装的路径，如果不配置该选项，安装后可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr /local/share，比较分散。为了便于集中管理某个软件的各种文件，可以配置–prefix，如：./configure –prefix=/usr/local</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以把所有资源文件放在/usr/local的路径中，就不会分散了。用了—prefix选项的另一个好处是卸载软件或移植软件。当某个安装的软件不再需要时，只须简单地删除该安装目录，就可以把软件卸载得干干净净；移植软件只需拷贝整个目录到另外一个机器即可（相同的操作系统）。当然要卸载程序，也可以在原来的make目录下用一次make uninstall，但前提是make文件指定过uninstall。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尤其是在服务器上，普通用户没有sudo权限，执行./configure会提示：./configure: Permission denied。可以使用–prefix将按照的配置路径放在自己的目录下，因为像/usr/local/lib此类的目录普通用户是没有写的权限的，会造成安装失败。失败的还要一种可能的原因是当前源码中的configure文件没有可执行权限，也会导致“Permission denied”。可以使用“ll”命令查看文件的权限，然后使用chmod命令对该文件加上可执行的权限“chmod +x ./configure”。</p>
<p>参考：</p>
<p><a href="http://www.maybe520.net/blog/1945/" target="_blank" rel="noopener">http://www.maybe520.net/blog/1945/</a></p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: 'linux-1:源码安装',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {
      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>]]></content>
      
        <categories>
            
            <category> liunx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[序列标注-2：命名实体识别]]></title>
      <url>/2018/01/17/ner2/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://sighan.cs.uchicago.edu/" target="_blank" rel="noopener">SIGHAN</a>是国际计算语言学会（ACL）中文语言处理小组的简称，其英文全称为“Special Interest Group for Chinese Language Processing of the Association for Computational Linguistics”.Bakeoff则是SIGHAN所主办的国际中文语言处理竞赛，第一届于2003年在日本札幌举行（Bakeoff 2003),第二届于2005年在韩国济州岛举行(Bakeoff 2005), 而2006年在悉尼举行的第三届（Bakeoff 2006）则在前两届的基础上加入了中文命名实体识别评测。目前SIGHAN Bakeoff已成功举办了6届，其中Bakeoff 2005的数据和结果在其主页上是完全免费和公开的，但是请注意使用的前提是非商业使用（non-commercial）:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The data and results for the 2nd International Chinese Word Segmentation Bakeoff are now available for non-commercial use.</p>
<p>The Third SIGHAN Chinese Language Processing Bakeoff will feature two tasks:</p>
<ul>
<li>Word Segmentation</li>
<li>Named Entity Recognition</li>
</ul>
<a id="more"></a>
<h3 id="Word-Segmentation-Task"><a href="#Word-Segmentation-Task" class="headerlink" title="Word Segmentation Task"></a>Word Segmentation Task</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;The Word Segmentation task requires identification of word boundaries in running Chinese text.</p>
<p>The following resources will be available:</p>
<p>Matched training and (new) test sets from:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Source Institution</th>
<th style="text-align:center">Character Encoding</th>
<th style="text-align:center">Approximate Size (chars)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CKIP, Academia Sinica, Taiwan</td>
<td style="text-align:center">Traditional, Big5</td>
<td style="text-align:center">8.3M</td>
</tr>
<tr>
<td style="text-align:center">City University of Hong Kong</td>
<td style="text-align:center">Traditional, Big5</td>
<td style="text-align:center">2.4M</td>
</tr>
<tr>
<td style="text-align:center">Microsoft Research</td>
<td style="text-align:center">Simplified, CP936</td>
<td style="text-align:center">5M</td>
</tr>
<tr>
<td style="text-align:center">University of PennsylvaniaUniversity of Colorado, Boulder</td>
<td style="text-align:center">Simplified</td>
<td style="text-align:center">1M</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Segmentation guidelines for the following corpora are available. These were supplied to SIGHAN by each data provider, and converted into PDF by the organizer:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Corpus</th>
<th style="text-align:center">MS Word</th>
<th style="text-align:center">PDF</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Academia Sinica</td>
<td style="text-align:center"><a href="http://sighan.cs.uchicago.edu/bakeoff2005/data/as_spec.doc" target="_blank" rel="noopener">516 KB</a></td>
<td style="text-align:center"><a href="http://sighan.cs.uchicago.edu/bakeoff2005/data/as_spec.pdf" target="_blank" rel="noopener">336 KB</a></td>
</tr>
<tr>
<td style="text-align:center">City University of Hong Kong</td>
<td style="text-align:center"><a href="http://sighan.cs.uchicago.edu/bakeoff2005/data/cityu_spec.doc" target="_blank" rel="noopener">154 KB</a></td>
<td style="text-align:center"><a href="http://sighan.cs.uchicago.edu/bakeoff2005/data/cityu_spec.pdf" target="_blank" rel="noopener">237 KB</a></td>
</tr>
<tr>
<td style="text-align:center">Microsoft Research</td>
<td style="text-align:center"><a href="http://sighan.cs.uchicago.edu/bakeoff2005/data/msr_spec.doc" target="_blank" rel="noopener">41 KB</a></td>
<td style="text-align:center"><a href="http://sighan.cs.uchicago.edu/bakeoff2005/data/msr_spec.pdf" target="_blank" rel="noopener">70 KB</a></td>
</tr>
</tbody>
</table>
<h3 id="Named-Entity-Recognition-Task"><a href="#Named-Entity-Recognition-Task" class="headerlink" title="Named Entity Recognition Task"></a>Named Entity Recognition Task</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;The Named Entity Recognition Task requires participants to identify named entities (person, location, and organization) in running unsegmented Chinese text.</p>
<p>The following resources will be available:</p>
<p>Matched training and (new) test sets from:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Source Institution</th>
<th style="text-align:center">Character Encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">City University of Hong Kong</td>
<td style="text-align:center">Traditional, Big5</td>
</tr>
<tr>
<td style="text-align:center">Microsoft Research</td>
<td style="text-align:center">Simplified, CP936</td>
</tr>
<tr>
<td style="text-align:center">Linguistic Data Consortium</td>
<td style="text-align:center">Simplified, CP936</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;You may declare that you will return results on any subset of these corpora. For example, you may decide that you will test on the Sinica Corpus and the City University corpus. The only constraint is that you <strong>must not</strong> select a corpus where you have knowingly had previous access to the testing portion of the corpus. A corollary of this is that a team may not test on the data from their own institution.</p>
<h2 id="Data-Formats"><a href="#Data-Formats" class="headerlink" title="Data Formats"></a>Data Formats</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Training data will be available for CityU and MSRA in two formats. The primary format will be similar to that of the Co-NLL NER task 2002, adapted for Chinese. The data will be presented in two-column format, where the first column consists of the character and the second is a tag. The tag is specified as follows:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Tag</th>
<th style="text-align:center">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0 (zero)</td>
<td style="text-align:center">Not part of a named entity</td>
</tr>
<tr>
<td style="text-align:center">B-PER</td>
<td style="text-align:center">Beginning character of a person name</td>
</tr>
<tr>
<td style="text-align:center">I-PER</td>
<td style="text-align:center">Non-beginning character of a person name</td>
</tr>
<tr>
<td style="text-align:center">B-ORG</td>
<td style="text-align:center">Beginning character of an organization name</td>
</tr>
<tr>
<td style="text-align:center">I-ORG</td>
<td style="text-align:center">Non-beginning character of an organization name</td>
</tr>
<tr>
<td style="text-align:center">B-LOC</td>
<td style="text-align:center">Beginning character of a location name</td>
</tr>
<tr>
<td style="text-align:center">I-LOC</td>
<td style="text-align:center">Non-beginning character of a location name</td>
</tr>
<tr>
<td style="text-align:center">B-GPE</td>
<td style="text-align:center">Beginning character of a geopolitical entity</td>
</tr>
<tr>
<td style="text-align:center">I-GPE</td>
<td style="text-align:center">Non-beginning character of a geopolitical entity</td>
</tr>
</tbody>
</table>
<h2 id="Test-data"><a href="#Test-data" class="headerlink" title="Test data"></a>Test data</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Test data will be provided one-sentence per line, unsegmented with no tags. Participants should format their results to conform to the training data format described above. Scoring will be done automatically using a variant of the Co-NLL 2003 scoring  script. Comments at the beginning of the file describe usage.</p>
<h1 id="论文总结"><a href="#论文总结" class="headerlink" title="论文总结"></a>论文总结</h1><p>论文题目：Chinese Named Entity Recognition with Conditional Random Fields</p>
<p>​    这篇论文使用了基本特征和辅助特征，而且加入了一个后处理的对不正确的结果进行纠正。主要是在特征的设计上面。</p>
<p><strong>1.基本特征</strong>：$C_n(n=-2,-1,0,1,2)$  $C_nC_n+1(n=-1,0)$</p>
<p>​    特征的使用是特征模板定义的，特征模板可以在一个上下文环境（窗口）中安装Unigram、Bigram、Trigram等使用特征。例如，在句子“中国和日本是邻邦“中，若当前字是”和“，Bigram模板C_2C-1/C-1C0、C0C1、C1C2将分别拓展出”中国“、”国和“、”和日“、”日本“四个特征。0.-1.-2,1,2表示相对当前字符及前后一个或者两个字符的位置。CRF模型就是根据这些特征及类别标签生成判别函数，最后在测试时为每一个token按概率最大原则打上相应的标签。</p>
<p><strong>2.辅助特征：</strong></p>
<p>1）词边界特征：</p>
<p>对人名而言，“先生“是一个重要特征。</p>
<ol>
<li><p>提取任意n元（$2&lt;=n&lt;=10\: Frequency&gt;=10$）得到列表$W_1$</p>
</li>
<li><p>使用SSR(Statistical Substring Reduction)算法得到列表$W_2$</p>
</li>
<li><p>构建一个字符列表$CH$ (在训练语料中出现频率前20的),为了收集像“的”，“了”的字符。</p>
</li>
<li><p>从列表中$W_2$移除在$CH$出现过的字符，得到$W_3$</p>
<p>用列表$W_3$作为一个字典从左向右最大匹配分词</p>
</li>
</ol>
<p>2）字符特征 </p>
<p>PSur: uni-gram characters, first characters of Person Name. (surname)</p>
<p>PC: uni-gram characters in Person Name.</p>
<p>PPre: bi-gram characters before Person Name. (prefix of Person Name)</p>
<p>PSuf: bi-gram characters after Person Name. (suffix of Person Name)</p>
<p>LC: uni-gram characters in Location Name or Geopolitical entity.</p>
<p>LSuf: uni-gram characters, the last characters of Location Name or Geopolitical Entity. (suffix of Location Name or Geopolitical Entity)</p>
<p>OC: uni-gram characters in Organization Name.</p>
<p>OSuf: uni-gram characters, the last characters of Organization Name. (suffix of Organization Name)</p>
<p>OBSuf: bi-gram characters, the last two characters of Organization Name. (suffix of Organization Name)</p>
<p><strong>3.后处理</strong></p>
<p>The post-processing tries to assign the correct tags according to n-best results for every sentence.</p>
<p>参考：</p>
<ol>
<li><a href="http://sighan.cs.uchicago.edu/bakeoff2006/" target="_blank" rel="noopener">http://sighan.cs.uchicago.edu/bakeoff2006/</a></li>
<li>Chinese Named Entity Recognition with Conditional Random Fields. Wenliang Chen</li>
</ol>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: '序列标注-2：命名实体识别',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {
      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>

]]></content>
      
        <categories>
            
            <category> ner </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ner </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[序列标注-1：命名实体识别]]></title>
      <url>/2018/01/16/ner/</url>
      <content type="html"><![CDATA[<h3 id="1-命名实体研究历史"><a href="#1-命名实体研究历史" class="headerlink" title="1.命名实体研究历史"></a>1.命名实体研究历史</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;国外对于英文命名实体识别的研究开始比较早。1991年Rau在第7届IEEE人工智能应用会议上发表了“抽取和识别公司名称”的有关研究文章, 首次描述了抽取和识别公司名称的系统, 该系统主要采用启发式算法和手工编写规则的方法，1996年, 命名实体评测作为信息抽取的一个子任务被引入MUC-6 ,在其后的MUC-7的MET-2 以及IEER-99、CoNLL-2002、CoNLL-2003、IREX、LREC等一系列国际会议中, 命名实体识别都被作为其中的一项指定任务。</p>
<a id="more"></a>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于中文内在的特殊性决定了在文本处理时首先必须进行词法分析, 中文命名实体识别的难度要比英文的难度大。中文命名实体识别起步较晚, 20世纪90年代初期开始, 国内一些学者对中文命名实体(如:地名、人名、组织机构名等)识别进行了一些研究。如:孙茂松等在国内比较早开始进行中文人名识别, 他们主要采用统计的方法计算姓氏和人名用字概率。张小衡等对中文机构名称进行识别与分析, 主要采用人工规则对高校名进行了实验研究。Intel中国研究中心的Zhang等在ACL2000上演示了他们开发的一个抽取中文命名实体以及这些实体间相互关系的信息抽取系统, 该系统利用基于记忆的学习(MemoryBased Learning, MBL)算法获取规则, 用以抽取命名实体及它们之间的关系。</p>
<h3 id="2-命名实体识别研究内容"><a href="#2-命名实体识别研究内容" class="headerlink" title="2.命名实体识别研究内容"></a>2.命名实体识别研究内容</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;早期的命名实体识别工作,主要识别一般的<strong>专有名词</strong>，包括三类名词：人名、地名、机构名。这也是MUC-6 最早定义的任务要识别的名词。随着研究的进行，人们对这些名词进行更细致的划分。对于地名，可以进行细分为：国家名、省/州、城市名、街道名等。类似的人名可以细分为：政客、演员等。除了识别一般的专有名词， 人们也开始关注对于特定领域的命名实体识别。在生物医学领域，对于基因名、蛋白质名的识别已经有许多工作在开展，也取得了不错的效果。针对社交媒体文本中存在大量的电影、歌曲等， 识别电影名、歌曲名、邮件地址等实体。随着研究范围的扩大，针对不同的特定问题特定领域， 越来越多的实体类型被提出。</p>
<h3 id="3-技术方法"><a href="#3-技术方法" class="headerlink" title="3.技术方法"></a>3.技术方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;早期的研究大多采用基于人工构造规则的方法，而现在大多使用监督的机器学习方法。监督学习方法的思想是在大量标注的文档上学习命名实体正例和负例的特征并设计捕获给定类型本质的规则。而语料库的缺乏和构造这些资源的高昂成本导致了两种可替代的学习方法，<strong>半监督学习</strong>和<strong>无监督学习</strong>。</p>
<h4 id="3-1-基于规则和词典的方法"><a href="#3-1-基于规则和词典的方法" class="headerlink" title="3.1.　基于规则和词典的方法"></a>3.1.　基于规则和词典的方法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于规则的方法多采用语言学专家手工构造规则模板, 选用特征包括统计信息、标点符号、关键字、指示<br>词和方向词、位置词(如尾字)、中心词等方法, 以模式和字符串相匹配为主要手段, 这类系统大多依赖于知<br>识库和词典的建立。一般而言, 当提取的规则能比较精确地反映语言现象时, 基于规则的方法性能要优于基于统计的方法。但是这些规则往往依赖于具体语言、领域和文本风格,编制过程耗时且难以涵盖所有的语言现象, 特别容易<br>产生错误, 系统可移植性不好, 对于不同的系统需要语言学专家重新书写规则。基于规则的方法的另外一个缺点是代价太大, 存在系统建设周期长、移植性差而且需要建立不同领域知识库作为辅助以提高系统识别能力等问题。</p>
<h4 id="3-2-监督学习"><a href="#3-2-监督学习" class="headerlink" title="3.2  监督学习"></a>3.2  监督学习</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前，命名实体识别所使用的主流技术是监督学习。监督学习包括隐马尔科夫模型、决策树、最大熵模型、支持向量机、条件随机场等，这些方法都是命名实体识别系统的变体，这些系统都是读取大量的标注语料，存储一系列实体，并且构造基于特征的判别规则。通常提出的基本监督方法包括标注测试语料库的词，这些词在训<br>练集中被注释为实体。系统的性能依赖于同时出现在训练语料库和测试语料库中的词所占的比例，通常称之为词汇转移。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大熵模型结构紧凑, 具有较好的通用性, 主要缺点是训练时间复杂性非常高,有时甚至导致训练代价难以承受, 另外由于需要明确的归一化计算, 导致开销比较大。而条件随机场为命名实体识别提供了一个特征灵活、全局最优的标注框架, 但同时存在收敛速度慢、训练时间长的问题。一般说来, 最大熵和支持向量机在正确率上要比隐马尔可夫模型高一些, 但是隐马尔可夫模型在训练和识别时的速度要快一些, 主要是由于在利用Viterbi算法求解命名实体类别序列的效率较高。隐马尔可夫模型更适用于一些对实时性有要求以及像信息检索这样需要处理大量文本的应用, 如短文本命名实体识别 。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于统计的方法对特征选取的要求较高, 需要从文本中选择对该项任务有影响的各种特征, 并将这些特征加入到特征向量中。依据特定命名实体识别所面临的主要困难和所表现出的特性, 考虑选择能有效反映该类实体特性的特征集合。主要做法是通过对训练语料所包含的语言信息进行统计和分析, 从训练语料中挖掘出特征。有关特征可以分为具体的单词特征、上下文特征、词典及词性特征、停用词特征、核心词特征以及语义特征等。张祝玉等针对条件随机场的特征选取与组合进行了比较研究, 通过实验比较得出在训练时应优先选择贡献度大的特征, 同时还表明使用组合特征可以提升系统的性能。</p>
<h4 id="3-3-半监督学习"><a href="#3-3-半监督学习" class="headerlink" title="3.3.半监督学习"></a>3.3.半监督学习</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于可用标注语料库的匮乏以及大量未标注语料库的存在，研究人员提出了一种半监督学习方法，也称为弱监督学习。主要的半监督学习方法被称为“bootstrapping”，它只需要提供少量的标注数据，例如一组种子用于开始的学习。然后，系统搜索包含这些已提供数据的句子并尝试发现出现在相似上下文中实体的其他实例。接着将学习过程应用于新发现的例子以发现新的相关上下文。通过重复这一过程收集大量命名实体和大量上下文信息。半监督方法只需要较少的已标注数据，从而在大量无标注数据的条件下获得可以与监督学习方法相媲美的性能。</p>
<h3 id="4-评估指标"><a href="#4-评估指标" class="headerlink" title="4.评估指标"></a>4.评估指标</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对命名实体识别系统的发展来说，对系统的全面评估是必不可少的，许多系统被要求根据它们标注文本的能力来对系统进行排序。目前，通常采用的评估指标主要有正确率、召回率和F 值，它们的定义如下：<br>​    $正确率P= 识别出的正确实体数/ 识别出的实体数$<br>​    $召回率R= 识别出的正确实体数/ 样本中的实体数。$<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两者的取值都在0 和1 之间，数值越接近1，正确率或召回率就越高。正确率和召回率有时会出现矛盾的情况，这时需要综合考虑它们的加权调和平均值，也就是F 值，其中最常用的F1 值，当F1 值较高时说明试验方法比较有效。</p>
<p>F1 值定义如下：<br>​    $   F1 =（2 \times P \times R）/（P+ R） $</p>
<p>参考：</p>
<ol>
<li>命名实体识别研究发展综述_周玉新</li>
<li>命名实体识别研究进展综述_孙镇</li>
<li>命名实体识别综述_陈基</li>
</ol>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: '序列标注-1：命名实体识别',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {
      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>






































]]></content>
      
        <categories>
            
            <category> ner </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ner </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[唐诗-1：复古的伟大继承人：李白]]></title>
      <url>/2018/01/16/poetry/</url>
      <content type="html"><![CDATA[<h1 id="复古的伟大继承人：李白"><a href="#复古的伟大继承人：李白" class="headerlink" title="复古的伟大继承人：李白"></a><p align="center">复古的伟大继承人：李白</p></h1><h2 id="古风"><a href="#古风" class="headerlink" title="古风"></a><p align="center">古风</p></h2><p align="center">大雅久不作，吾衰竟谁陈？<br>王风委蔓草，战国多荆榛。<br>龙虎相啖食，兵戈逮狂秦。<br>正声何微茫，哀怨起骚人。<br>扬马激颓波，开流荡无垠。<br>废兴虽万变，宪章亦已沦。<br>自从建安来，绮丽不足珍。<br>圣代复元古，垂衣贵清真。<br>群才属休明，乘运共跃鳞。<br>文质相炳焕，众星罗秋旻。<br>我志在删述，垂辉映千春。<br>希圣如有立，绝笔于获麟。<br></p>

<a id="more"></a>
<p>注释</p>
<ol>
<li>大雅：《诗经》之一部分。此代指《诗经》。作：兴。吾衰：《论语·述而》：“子曰：甚矣，吾衰也。”陈：《礼记·王制》：“命太史陈诗以观民风。”</li>
<li>王风：《诗经·王风》，此亦代指《诗经》。委蔓草：埋没无闻。此与上句“久不作”意同。多荆榛：形容形势混乱。</li>
<li>龙虎：指战国群雄。啖食：吞食，此指吞并。兵戈：战争。逮：直到。</li>
<li>正声：雅正的诗风。骚人：指屈原。</li>
<li>扬马：指汉代文学家扬雄、司马相如。</li>
<li>宪章：本指典章制度，此指诗歌创作的法度、规范。沦：消亡。</li>
<li>建安：东汉末献帝的年号（196～219），当时文坛作家有三曹、七子等。绮丽：词采华美。</li>
<li>圣代：此指唐代。元古：上古，远古。垂衣：《易·系辞下》 ：“黄帝、尧、舜垂衣裳而天下治。” 意谓无为而治。清真：朴素自然，与绮丽相对。</li>
<li>“群才”句：文人们正逢休明盛世。属：适逢。跃鳞：比喻施展才能。</li>
<li>“文质”句：意谓词采与内容相得益彰。秋旻：秋天的天空。</li>
<li>删述：《尚书序》：“先君孔子……删《诗》为三百篇，约史记而修《春秋》，赞《易》道以黜《八索》，述职方以除《九丘》。”</li>
<li>希圣：希望达到圣人的境界。获麟：《春秋·哀公十四年》：“西狩获麟，孔子曰‘吾道穷矣’。”传说孔子修订《春秋》，至此搁笔不复述作。因为他认为骐麟出非其时而被猎获，不是好兆。以上四句意谓：李白欲追步孔子，有所述作，以期后垂名不朽。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“大雅”指的是什麽？就是《诗经》。尤其是所谓的“雅”这个字 那更是一种所谓的雅正风范。作为文学正统，它和“国风” 是不大一样的。“国风”从某个层次来讲，它还是比较偏向于一般民间，它最初是来自民间的风谣。当然，被采集到政府机构以后，其实经过了贵族阶层的整理，也受到精英知识份子的润色、雅化其实已经不能算是民间的作品，也不是各地民歌原来的面貌，它事实上是周代贵族阶层的产物了因此才会并称为“风雅”。国风的诗篇尚且如此，至于“雅” 字，那绝对是庙堂之音。 李白又说，文学正统还是要由大雅来建立。它生生不息、 绵延万代，这个基本上就是古代文人最确切不疑、天经地义的一种信念 。这么一来，连李白这样子高歌“我本楚狂人，凤歌笑孔丘”的一位诗人，很奔放、 很潇洒，甚至鼓励了很多年轻人去违抗现实束缚的一个不羁的灵魂 他实际上还是活在中国传统脉络底下的。可想而知 儒家的价值观可以说是古代文人血液里的DNA 这个价值观对他们而言是不可能打折扣的，所以李白说： 很可惜啊，在大雅之后，这个完美的、正统的、 真实的文学生命，已经长久被忽略了，而沉坠不振了。所以李白下面接著说「吾衰竟谁陈」 他说：可是我已经衰老了、衰退了、衰弱了，这样一来又有谁能够去把这样一个衰退的正统给 重新继承下来，再度加以振发？加以复活呢？ 而“吾衰竟谁陈”这句话应该会让读者立刻想到 其实李白就是以孔子为自期，“吾衰竟谁陈”根本就是套用孔子的话。 孔子说：“甚矣，吾衰也！久矣，吾不复梦见周公。” 人家梦周公可不是在说睡觉的意思，而是他想要去继承、 去发扬，去把那样一个由周公制礼作乐所形成的文化大传统，给内化成为自己的灵魂的一部分。 因此就会像庄子所说的：“其寐也魂交” 一旦全心全意的追求，深入到潜意识的内里，我们所渴望追求的对象就会在梦中 出现，所以如果连做梦都没有梦见周公，那就表示离周公伟大的礼乐精神已经有了距离。那这就是孔子的感慨，感慨说，那是不是我衰老了，是不是我的精神血性，不足以把这样的大生命、 大传统给继承下来？所以李白一开始的“大雅久不作，吾衰竟谁陈”。就表明了他是以孔子自许的，他要像孔子一样把那个由周公所建构的而成的文化传统的核心 那最源源不断的生机的来源化为己任。就像孔子承担了这个责任 一样，现在李白也说我要承担下来，甚至李白认为除了他自己以外 没有别人可以承担下来。「吾衰竟谁陈」就是这个意思，颇为当仁不让、捨我其谁 就李白这个人物而言，我们读他很多的作品以后就会发现，他事实上还是一个非常正统的传统的知识份子，这个知识份子还是以儒家的价值观，作为他生命真切不疑的最高指导原则 这是没有谁能够例外的，杜甫也不例外，苏东坡也不例外，陶渊明也不例外，曹雪芹也不例外 所以一开始李白就觉得当仁不让、舍我其谁，他要以 孔子自许，在诗歌发展起起伏伏的这一条曲折的河流中 李白自我定位在孔子的地位上，他要做文学史上的孔子。 那位不但继承周公的礼乐文化，同时也为后来的人点燃灵根般，成为中国文化传统的一位 至圣先师。 宋代人就说：“天不生仲尼，则万古如长夜”， 他们认为假如没有孔子的话，中国文化就会陷入到无限的黑暗里，就这点来说 孔子简直不但是这个传统文化的核心主轴，甚至还是唯一的一颗恒星 他带来一切这个文化的光亮，所以就这点来说李白会以孔子 自许，你就该知道那是多麽大的自信，<br>以及多麽大的自我期望！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来各位请看，就在这一段 李白用了和陈子昂同样的操作方式，所谓“大雅久不作” 是不是就等于“王风委蔓草”，是不是就等于“正声何微茫”，也就是等于 “宪章亦已沦”，那个消失不见的价值。他用了四个文句来说明 而那四个文句所指涉的不同语词，其实都是同一个意义 你看，“大雅”就等于“王风”，就等于“正声”，等于“宪章”，都是一种永恒 不变的价值，而“久不作”就是“委蔓草”，就是“何微茫”，就是“亦已沦”， 也就是它们都被否定了，都消沉不见了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这首诗的下面又更清楚了，李白说：“自从建安来，绮丽不足珍”，这十个字 可以说是只要提到李白的复古理论，一定都会涉及到的经典名言对李白而言，固然《诗经》的正统已经沦丧，如他前面所反覆强调的，可是 《诗经》之后，确实还有一个在“委蔓草”、“何微茫”、“亦已沦”的衰颓状态中独一无二的中流砥柱，这个中流砥柱就是“建安”。所以李白说建安在《诗经》这个宪章沦落了四百年之久以后啊 它终于恢复了正统。可是很可惜，建安之后又走上了另外一条岔路，那条岔路是 以绮丽作为追求的目标，而这个绮丽却又是被李白这一类的复古诗人认为最不重要的文学追求。所以李白说“绮丽不足珍”，这麽一来建安和绮丽 就变成一个二元的对立组，而且这个二元的对立组和陈子昂所说的如出一辙，陈子昂不也说“僕尝暇时观齐、梁间诗，彩丽竞繁 而兴寄都绝”吗？可以说李白这首诗就是对陈子昂的直接回应 只是陈子昂的是书信的散文版，那麽李白是诗歌的韵文版，事实上 意思完全一样，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;李白进一步说：“圣代复元古，垂衣贵清真”， 清、真这两个字，已经不是老庄“垂拱而治，清静无为” 政治上面的不扰民的意思，而是指诗歌的一种对纯粹情志的追求。不再以绮丽的雕虫小技来覆盖文学的原貌 。不要有太繁缛的那些装扮，那些彩丽的文字，脂粉气太浓了 覆盖在文字上面，遮蔽了真性情，真心灵，你都可以洗掉了，恢复它清雅的面貌吧！而这裡所说的清、真 确确实实在李白的许多其他地方也反覆地出现过，例如像《古风五十九首》里面第三十五首也提到 “一曲斐然子，雕虫丧天真”。 后来在一首晚年的长诗里面也提到：“清水出芙蓉，天然去雕饰” 其中“清”和“真”都代表一种由衷的、真实的、 天然的特质，基本上就是李白复古思想，以及他创作上最重要的核心指标由此可见，任何一个人要能成为一个大生命。他都绝对不会只顾及到自己的名利地位，他要想的是 把传统里面最好的东西，任何点点滴滴有价值的养分，他都希望 可以传承下去，而我们作为历史的一部分，实际上也都应该用这样的一种历史意识，透过古往今来的宏大视野来看待一切问题，不要只活在当下，目光如豆地 聚焦在一个该死的自我上，而是应该要恢复“人作为一个人”的最高尊严 那就是，你能够了解过去，也能够期许未来，<br>然后把自我扩充为整个时代的成员之一，薪火相传 这么一来，人才会拥有真正的灵魂。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以你看，接下来李白说：盛唐是一个“众星罗秋旻，群才属休明”的时代，是一个人才济济，像无数闪耀的星星在天空中星罗棋布 大家都要来共同参与历史阶段裡这一个昂扬的、盛明的大好时代。 那么我，也就是李白，该做什麽事情呢？你看他又回了到个人身上，给自己一个宏大的责任、宏大的期许 到此为止，《古风》的这第一首诗歌，其中的诗歌主张已经非常清楚了 李白在其它地方也一再做出类似的表达，例如 《古风》的第三十首，他还说：“玄风变太古，道丧无时还。” 尤其是我们再来参考唐代 有一位孟棨，他在《本事诗》中又记载了李白有一段著名的名言 李白说：“梁陈以来，艳薄斯极”，“沉休文”（就是沉约）又尚以声律”，就是追求格律于是他说：“将复古道，非我而谁？”所谓的 “梁陈以来，艳薄斯极”，岂非就是陈子昂所说的“齐梁间诗，彩丽竞繁”吗？ 那所谓的“沉休文又尚以声律”，这句中的沉休文，也就是南朝齐梁诗坛上的沉约 他在文学史上面最重要的贡献，就是他是奠定格律的先锋。 如此一来，绮丽的这一脉发展就被贬低了，也被否定了。 李白的“将复古道，非我而谁”，也就等于是“大雅久不作，吾衰竟谁陈”。 李白要当仁不让地以诗歌中的孔子自居要去恢复、振拔文学的大生命，追求理想的永恒不朽。最后的“我志在删述，垂辉映千春。 希圣如有立，绝笔于获麟。” 这四句话其实是在回应前面的第一联，李白不就是用孔子来自许，他在诗歌结束的地方又回到 孔子身上，起结，也就是开头和结尾，都以孔子作为坐标 就可想而知，李白气魄是很大的，他不甘于只做一个小小的诗人而已 他觉得即使要做一个诗人，都应该要有孔子的胸襟和目标，给自己一个宏大的眼光。 所以他说：“我志在删述，垂辉映千春。” 你看，他的志向是什麽？他的志向是，要像孔子一样地删诗书，然后述而不作这里当然不是指学术思想上面的，不是指那个文化上面的事业。 他指的是，要在诗歌的历史里面，达到像孔子在整个中国文化里面所达到的成就，这样一个给自己最高的期许。 他说，这麽一来，他的生命所散发的光芒就可以辉映著千年的历史千春，就是千秋，就是千年，也就是永恒。 所以李白是不争一时的，他是要争千秋的。 因此他尽其在我的努力，感谢盛唐这个大时代带给他们的灵魂养分，让自己壮大，让自己努力地散发光芒 这个光芒如果足够，就可以照耀千古、辉映后代。 所以李白说：那个志气是很大的，他也不知道自己究竟能不能做得到 但是，如同司马迁所说的：「虽不能至，心嚮往之。」 要有这样的嚮往之情，人的灵魂才会维持在一个高度，不会逐渐地低落、下坠而不自知。 假如我没有这样一种仰望的志向在护持著、 维繫著一种精神高度，人就会越来越活在庸俗生活的浅水沙滩里然后就斤斤计较于小小的得失，志气就会越来越衰颓，终究就被消磨殆尽。参考一下白居易所说的：“蜗牛角上争何事？石火光中寄此身。” 确实，当我们眼界大的时候就会知道，我们所在的世界真的只是一个小小的蜗牛角。而原来我们就在一个好狭窄的地方拥挤著，你争我夺，费力追求一些恐怕临死回顾的时候，根本就不觉得重要的东西。但这就是人性。 一旦不加以警觉，人们不知不觉就会走上“在蜗牛角你争我夺”这样的一条路。 所以，我们才需要时时刻刻给自己一个大视野、大提醒，重点就在于这里。 所以李白说：“希圣如有立，绝笔于获麟。” 他说希圣，就是希望能达到圣人所达到的境界，也就是指孔子所展现的崇高境界。 如果这个期望能够达到的话，让他也能够在这个文明里面有所成就、 有所奠定，能够立足在诗歌的历史高峰上“垂辉映千春”，那麽李白就会像孔子 一样“绝笔于获麟”，也就是等到获麟事件发生之后才会停笔 意思就是说：不到死，他绝不会停下笔来。这就清楚宣告了李白终其一生的坚持和努力。 如此一来，各位想想，又岂能够说李白是一个反对儒家的叛逆者呢？</p>
<p>参考：</p>
<ol>
<li>欧丽娟，台湾大学</li>
<li><a href="http://so.gushiwen.org/shiwenv_5835f8a8117b.aspx" target="_blank" rel="noopener">http://so.gushiwen.org/shiwenv_5835f8a8117b.aspx</a></li>
</ol>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: '唐诗-1：复古的伟大继承人：李白',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {
      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[序列标注]]></title>
      <url>/2018/01/16/sequence-laneling/</url>
      <content type="html"><![CDATA[<h2 id="1-什么是序列标注？"><a href="#1-什么是序列标注？" class="headerlink" title="1.什么是序列标注？"></a>1.什么是序列标注？</h2><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们在NLP任务中一直面临的一个元问题，我们希望在一个序列中为每个元素分配一个标签。对我们来说，一个序列通常是一个句子，一个词是一个元素。我们试图分配的元素通常是词性、句法块标签（是名词短语、动词短语等的一部分），命名实体标记（这是一个人吗？）凡此种种，不一而足。信息提取系统（比如从电子邮件中提取会议时间和地点）也可以被视为序列标记问题。</p>
<h3 id="1-1-任务："><a href="#1-1-任务：" class="headerlink" title="1.1.任务："></a>1.1.任务：</h3><p>$f:{X} {sequence} \to {Y}  sequence $</p>
<p>$X:X_1 \:  X_2\: X_3\:…X_L$</p>
<p>$Y:Y_1 \:  Y_2 \:  Y_3 \: …Y_L$</p>
<p>目标：$Given\:X,predcit\: Y$</p>
<a id="more"></a>
<h3 id="1-2-有两种序列标注："><a href="#1-2-有两种序列标注：" class="headerlink" title="1.2 .有两种序列标注："></a>1.2 .有两种序列标注：</h3><font face="Times New Roman"><br><br>1. raw labeling:Raw labeling is something like POS tagging where <strong>each element gets a single tag</strong><br><br>2.  joint segmentation and labeling: Joint segmentation and labeling is where whole segments get the same label.</font>

<p>   ​</p>
<p>   举个例子，在命名实体识别中，像</p>
<p>   “Yesterday , George Bush gave a speech. ”</p>
<p>   这里我们想给“George Bush”整个标注“PERSON”而不是单个的字。如果两个字被命名，我们需要在哪隔开。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决这个问题最容易的方法是把他们转换为raw labeling problems。标准的方法是通过“B-X”，“I-X”或者“O”对每个字进行“BIO”编码，其他的编码方式也是可以的。如下所示：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yesterday/O  ,/O    George/B-PER    Bush/I-PER    gave/O    a/O   speech/O   ./O</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意要避免产生不可能的序列，如”I-X” 只可能出现在”B-X” 或者 “I-X”后面。</p>
<h2 id="2-标签编码表示"><a href="#2-标签编码表示" class="headerlink" title="2.标签编码表示"></a>2.标签编码表示</h2><h3 id="2-1-IO-编码"><a href="#2-1-IO-编码" class="headerlink" title="2.1. IO 编码"></a>2.1. IO 编码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最简单的编码是IO编码，标签要么是实体X的（I_X）要么是无实体（O）。这种编码是有缺陷的，因为它不能表示彼此相邻的两个实体，因为没有边界标记。</p>
<h3 id="2-2-BIO-Encoding"><a href="#2-2-BIO-Encoding" class="headerlink" title="2.2 .BIO Encoding"></a>2.2 .BIO Encoding</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行业标注编码是“BIO”编码，它划分实体标签要么是实体的开始部分“B_X”和实体的延续“I_X”</p>
<h3 id="2-3-BMEWO-Encoding"><a href="#2-3-BMEWO-Encoding" class="headerlink" title="2.3.BMEWO Encoding"></a>2.3.BMEWO Encoding</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BMEWO编码进一步区分实体，增加了结束标签E_X，M和I是一样的，尤其增加了一个完整的单实体标签。BMEWO编码最早介绍在<a href="http://citeseer.ist.psu.edu/old/699859.html" target="_blank" rel="noopener">Andrew Borthwick的 NYU thesis</a> 和1998年相关的论文最大熵命名实体识别中。</p>
<h2 id="3-序列标注"><a href="#3-序列标注" class="headerlink" title="3.序列标注"></a>3.序列标注</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似的，分词、词性标注、语块识别、<a href="http://book.paddlepaddle.org/07.label_semantic_roles/index.cn.html" target="_blank" rel="noopener">语义角色标注</a>等任务都可通过序列标注来解决。序列标注可以分为Sequence Classification、Segment Classification和Temporal Classification三类<a href="http://models.paddlepaddle.org/2017/04/21/sequence-tagging-for-ner-README.html#参考文献" target="_blank" rel="noopener">Supervised Sequence Labelling with Recurrent Neural Networks</a>]，这里只考虑Segment Classification，即对输入序列中的每个元素在输出序列中给出对应的标签。对于NER任务，由于需要标识边界，一般采用<a href="http://book.paddlepaddle.org/07.label_semantic_roles/" target="_blank" rel="noopener">BIO标注方法</a>定义的标签集。在raw labeling中，我们面临的问题是给序列中的每个字打上一个标签。也许最容易的方法是独立的预测每个标签。然后可以看做一个多分类的任务（每个标签是不同的分类）。我们可以使用各种分类器来解决这个问题。尽管它很简单，但这种方法对许多问题是非常<a href="http://arxiv.org/abs/cs/0111003" target="_blank" rel="noopener">有效</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直觉上，我们通常认为这些问题中的标签不是独立的。以词性标注为例，不可能有一个动词跟着限定词。因此，我们想使用局部序列信息来提高我们的性能。传统的方法是用<a href="http://nlp.stanford.edu/fsnlp/" target="_blank" rel="noopener">隐马尔科夫</a>。在这里我们有两个概率分布：一个是转移概率（限定词后面跟着动词的可能性）；二是发射概率（“the”是限定词的可能性）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用隐马尔可夫的潜在问题是我们知道发射概率$ P(word|tag)$,但是我们想知道模型$P(tag|word)$ 后者更可取，因为他包含了许多重叠特征（大写、单词标识、前缀，后缀，主干等）。局部的解决是用最大熵马尔科夫模型<a href="http://www.cs.iastate.edu/~honavar/memm-icml2000.pdf" target="_blank" rel="noopener">MEMM</a> ,即使用最大熵模型对模型$P(tag|word)$ 建模，而其他的地方跟隐马尔可夫模型保持一样。最大熵马尔科夫模型比隐马尔可夫模型的训练复杂一点，但是效果好得多。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最大熵马尔科夫潜在的问题是当模型训练的时候，它们训练出来与先前的正确标签的有冲突。这是因为我们创建一个与时间$t+1$ 中的标签相对于的分类示例时，我们包含的特征依赖于时间$t$的标签，它们在训练的时刻总是对的，但是在测试的时刻是错误的。这导致了著名的“标签偏移”问题。CRF是解决这个问题的答案。CRF经常表现比MEMM更好。<a href="http://mallet.cs.umass.edu" target="_blank" rel="noopener">CRF implement</a></p>
<p>参考资料：</p>
<p><a href="https://nlpers.blogspot.com.au/2006/11/getting-started-in-sequence-labeling.html" target="_blank" rel="noopener">https://nlpers.blogspot.com.au/2006/11/getting-started-in-sequence-labeling.html</a></p>
<p><a href="https://lingpipe-blog.com/2009/10/14/coding-chunkers-as-taggers-io-bio-bmewo-and-bmewo/" target="_blank" rel="noopener">https://lingpipe-blog.com/2009/10/14/coding-chunkers-as-taggers-io-bio-bmewo-and-bmewo/</a></p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: '序列标注',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {
      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>


]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[训练集 验证集 测试集]]></title>
      <url>/2018/01/13/%E8%AE%AD%E7%BB%83%E9%9B%86-%E9%AA%8C%E8%AF%81%E9%9B%86-%E6%B5%8B%E8%AF%95%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>在机器学习中划分数据的过程中总是有几个疑问？</p>
<p><strong>(1).Why only three partitions? (training, validation, test)?</strong></p>
<p><strong>(2).What is the difference between test set and validation set?</strong></p>
<a id="more"></a>
<p><font face="Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In  <strong>machine</strong> learning, the study and construction of algorithms that can learn from and make predictions on data is a common task. Such algorithms work by making data-driven predictions or decisions,through building a mathematical model from input data.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The data used to build the final model usually comes from multiple datasets. In particular, three data sets are commonly used in <strong>different stages</strong> of the creation of the model.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The model is initially <strong>fit</strong> on a training dataset that is a set of examples used to fit the parameters (e.g. weights of connections between neurons in artificial neural networks of the model. The model (e.g. a neural net or a naive Bayes classifier is trained on the training dataset using a supervised learning method (e.g. gradient descent or stochastic gradient descent). In practice, the training dataset often consist of pairs of an input vector and the corresponding <em>answer</em> vector or scalar, which is commonly denoted as the <em>target</em>. The current model is run with the training dataset and produces a result, which is then compared with the <em>target</em>, for each input vector in the training dataset. Based on the result of the comparison and the specific learning algorithm being used, the parameters of the model are adjusted. The model fitting can include both Feature_selection and parameter estimation.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Successively, the fitted model is used to predict the responses for the observations in a second dataset called the <strong>validation dataset</strong>.The validation dataset provides an  <strong>unbiased evaluation</strong>  of a model fit on the training dataset while tuning the model’s  <strong>hyperparameters</strong>  (e.g. the number of hidden units in a neural network) by early stopping: stop training when the error on the validation dataset increases, as this is a sign of overfitting to the training dataset. This simple procedure is complicated in practice by the fact that the validation dataset’s error may fluctuate during training, producing multiple local minima. This complication has led to the creation of many ad-hoc rules for deciding when overfitting has truly begun.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finally, the <strong>test dataset</strong> is a dataset used to provide an unbiased evaluation of a <em>final</em> model fit on the training dataset.</font> </p>
<h2 id="1-Training-dataset"><a href="#1-Training-dataset" class="headerlink" title="1.Training dataset"></a>1.Training dataset</h2><p><font face="Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A training dataset is a dataset of examples used for learning, that is to fit the parameters (e.g., weights) of, for example, a classifier).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Most approaches that search through training data for empirical relationships tend to <strong>overfit</strong>  the data, meaning that they can identify apparent relationships in the training data that do not hold in general.</font></p>
<h2 id="2-Test-dataset"><a href="#2-Test-dataset" class="headerlink" title="2.Test dataset"></a>2.Test dataset</h2><p><font face="Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A test dataset is a dataset that is  <strong>independent</strong>  of the training dataset, but that follows the same <strong>probability distribution </strong> as the training dataset. If a model fit to the training dataset also fits the test dataset well, minimal overfitting has taken place . A better fitting of the training dataset as opposed to the test dataset usually points to overfitting.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A test set is therefore a set of examples used only to assess the performance (i.e.  <strong>generalization</strong> ) of a fully specified classifier.</font></p>
<h2 id="3-Validation-dataset"><a href="#3-Validation-dataset" class="headerlink" title="3.Validation dataset"></a>3.Validation dataset</h2><p><font face="Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A validation dataset is a set of examples used to tune the <strong>hyperparameters</strong>  (i.e. the architecture) of a classifier. In artificial neural networks, a hyperparameter is, for example, the number of hidden units. It, as well as the testing set (as mentioned above), should follow the same probability distribution as the training dataset.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>In order to avoid overfitting</strong>  , when any classification parameter needs to be adjusted, it is necessary to have a validation dataset in addition to the training and test datasets. For example, if the most suitable classifier for the problem is sought, the training dataset is used to train the candidate algorithms, the validation dataset is used to compare their performances and decide which one to take and, finally, the test dataset is used to obtain the performance characteristics such as accuracy, sensitivity, specificity, F-measure, and so on. The validation dataset functions as a hybrid: it is training data used by testing, but neither as part of the low-level training nor as part of the final testing.</font></p>
<h2 id="4-意义"><a href="#4-意义" class="headerlink" title="4.意义"></a>4.意义</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，机器学习中包含两种参数。一是普通参数和超参数。对应到神经网络中，普通参数为权重，超参数为隐藏层单元的个数，迭代的次数等。我们通常会将数据集划分为三部分，训练集、验证集、测试集。比例为8:1:1。三个集合无交集是同分布的。训练集用来学习普通的参数。验证集用来验证学习到的模型的准确率，调整模型的超参数，在神经网络中可以是隐藏单元的个数或者确定网络的结构（model selection）。测试集是对验证集中挑选出的模型进行最终的性能检测。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 例如在神经网络的训练中，验证集是没有参与训练的过程的。但是，在超参数的选择中，我们根据验证集的结果调整迭代的次数等，从这个角度上看，验证集也是参与了调参的过程。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，如果是在比赛中，官方提供的数据只有一个训练集和无标签的测试集。由于官方一般给的训练集不是很多，一般不用再划分一个测试集。</p>
<p>参考资料：<a href="https://en.wikipedia.org/wiki/Training,_test,_and_validation_sets" target="_blank" rel="noopener">维基百科</a></p>
<p><div id="container"></div></p>
<p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: 'window.location.pathname', // 可选。默认为 location.href
  title: '训练集 验证集 测试集',
  owner: 'goingcoder',
  repo: 'goingcoder.github.io',
  oauth: {
      client_id: 'de24b44123b8efbb4747',
      client_secret: '785f51974278cde45a927a91a8438ef35eab9dd0',

  },
})
gitment.render('container')
</script>

]]></content>
      
        
    </entry>
    
  
  
</search>
